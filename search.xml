<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HNOI2015解题报告]]></title>
      <url>%2F2017%2F04%2F07%2FHNOI2015%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[HNOI2015解题报告 Author: Pengyihao Day1 T1 亚瑟王 思路 用 \(f[i][j]\) 表示 \(i\) 一共获得了 \(j\) 次“机会”的概率。 注意这里的“机会”，是指有多少轮中，它前面的所有卡牌，要么在之前的轮中发动过，要么在这一轮中因为运气没有发动。 这里的“机会”不与自己有没有发动相关。所以就算在之前某轮中发动过，这一轮轮到它的时候贡献依然要增加。 于是有 \(f[i][j] = f[i-1][j+1]\cdot (1-(1-p[i-1])^j) + f[i-1][j]\cdot (1-p[i-1])^j\) \(ans = \sum_{i=1}^n\sum_{j=1}^rf[i][j]\cdot d[i]\cdot (1-(1-p[i])^j)\) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 230, MAXR = 140;int T, n, r, d[MAXN];double p[MAXN], f[MAXN][MAXR];double power(double x, int y)&#123; double ret = 1; while (y) &#123; if (y &amp; 1) ret *= x; x *= x; y &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; freopen("arthur.in", "r", stdin); freopen("arthur.out", "w", stdout); in(T); while (T--) &#123; in(n); in(r); FOR(i, 1, n) &#123; scanf("%lf", &amp;p[i]); in(d[i]); &#125; memset(f, 0, sizeof f); f[1][r] = 1; FOR(i, 2, n) FOR(j, 1, r) &#123; f[i][j] = 0; f[i][j] += f[i - 1][j + 1] * (1 - power(1 - p[i - 1], j + 1)); f[i][j] += f[i - 1][j] * power(1 - p[i - 1], j); &#125; double ans = 0; FOR(i, 1, n) FOR(j, 1, r) &#123; ans += f[i][j] * (1 - power(1 - p[i], j)) * d[i]; &#125; printf("%.10lf\n", ans); &#125; return 0;&#125; Day1 T2 接水果 思路 首先，我们求出每个点的dfs序。 然后对于一条x&lt;–&gt;y的路径，如果有路径包含它，那么有 如果 \(lca(x,y)=x or y\)，那么只需要这条路径的一个端点在深度大的点的子树中，另一个端点不在“深度小的点往深度大的点的方向上的第一个点”的子树中即可。 否则，那么只需要这条路径的两个端点分别在 \(x\) 和 \(y\) 的子树中即可。 我们令这条包含x&lt;–&gt;y的路径的两个端点中dfs序小的点为 \(a\)，dfs序大的点为 \(b\)。 对于上面两种情况中的任意一种情况，这种情况中 \(a\) 和 \(b\) 所在的子树互不相交，为两个不相交的dfs序区间（不在子树中的情况我们可以转化为在它的补集的区间的情况）。 于是我们就把问题转化为了，每个盘子对应一对（或两对，因为有“不在子树”）区间，然后对于每个水果的两个点，两个区间分别包含其两个点的盘子中，权值第 \(k\) 小的。 我们可以把一维转化成 \(x\) 坐标，另一维转化成 \(y\) 坐标，于是问题就转化为了包含一个点的矩形中第 \(k\) 小的。 于是可以用扫描线+树状数组套主席树解决。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#include &lt;bits/stdc++.h&gt;using std::map;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)#define debug(...) fprintf(stderr, __VA_ARGS__)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 100010;const int appear = 0, disappear = 2, query = 1;int n, p, q, ev_tot;int cnt, head[MAXN], data[MAXN &lt;&lt; 1], nxt[MAXN &lt;&lt; 1];int INDEX, dfn[MAXN], ed[MAXN], depth[MAXN];int anc[MAXN][18];int ans[MAXN];map&lt;int, int&gt;M; int M_point, to[MAXN &lt;&lt; 3];struct Event &#123; int type, num; int time, l, r, w;&#125; ev[MAXN &lt;&lt; 3];namespace segment_tree&#123; const int MAXS = MAXN * 250; int seg_tot = 0, rot[MAXN], sz[MAXS], ch[MAXS][2]; int should_remove[250], should_add[250]; void build(int &amp;now, int l, int r) &#123; now = ++seg_tot; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(ch[now][0], l, mid); build(ch[now][1], mid + 1, r); &#125; void initialize() &#123; build(rot[0], 1, M_point); FOR(i, 1, n) rot[i] = rot[0]; &#125; void push(int &amp;now, int l, int r, int x, int modi) &#123; int tmp = now; now = ++seg_tot; sz[now] = sz[tmp]; ch[now][0] = ch[tmp][0]; ch[now][1] = ch[tmp][1]; sz[now] += modi; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) push(ch[now][0], l, mid, x, modi); else push(ch[now][1], mid + 1, r, x, modi); &#125; void getdown(int &amp;ret, bool t) &#123; ret = 0; FOR(i, 1, should_add[0]) ret += sz[ch[should_add[i]][t]]; FOR(i, 1, should_remove[0]) ret -= sz[ch[should_remove[i]][t]]; &#125; void godown(bool t) &#123; FOR(i, 1, should_add[0]) should_add[i] = ch[should_add[i]][t]; FOR(i, 1, should_remove[0]) should_remove[i] = ch[should_remove[i]][t]; &#125; void _query(int w, int l, int r, int num) &#123; if (l == r) &#123; ans[num] = l; return; &#125; int ldata; getdown(ldata, 0); int mid = (l + r) &gt;&gt; 1; if (ldata &gt;= w) &#123;godown(0); _query(w, l, mid, num);&#125; else &#123;godown(1); _query(w - ldata, mid + 1, r, num);&#125; &#125; void insert(int l, int r, int w) &#123; if (l &gt; r) &#123; debug("WA"); &#125; //This line is for gdb while (l &lt;= n) &#123; push(rot[l], 1, M_point, w, 1); l += l &amp; -l; &#125; r++; while (r &lt;= n) &#123; push(rot[r], 1, M_point, w, -1); r += r &amp; -r; &#125; &#125; void remove(int l, int r, int w) &#123; while (l &lt;= n) &#123; push(rot[l], 1, M_point, w, -1); l += l &amp; -l; &#125; r++; while (r &lt;= n) &#123; push(rot[r], 1, M_point, w, 1); r += r &amp; -r; &#125; &#125; void query(int l, int r, int w, int num) &#123; l--; should_remove[0] = should_add[0] = 0; while (l) &#123; should_remove[++should_remove[0]] = rot[l]; l -= l &amp; -l; &#125; while (r) &#123; should_add[++should_add[0]] = rot[r]; r -= r &amp; -r; &#125; _query(w, 1, M_point, num); &#125;&#125;int lca(int x, int y)&#123; if (depth[x] &lt; depth[y]) x ^= y ^= x ^= y; if (depth[x] != depth[y]) &#123; int delta = depth[x] - depth[y]; DNF(i, 17, 0) if (delta &gt;&gt; i &amp; 1) x = anc[x][i]; &#125; if (x == y) return x; DNF(i, 17, 0) if (anc[x][i] &amp;&amp; anc[y][i] &amp;&amp; anc[x][i] != anc[y][i]) &#123; x = anc[x][i]; y = anc[y][i]; &#125; return anc[x][0];&#125;void work(int now)&#123; if (ev[now].type == appear) &#123; segment_tree::insert(ev[now].l, ev[now].r, ev[now].w); &#125; else if (ev[now].type == disappear) &#123; segment_tree::remove(ev[now].l, ev[now].r, ev[now].w); &#125; else &#123; segment_tree::query(1, ev[now].l, ev[now].w, ev[now].num); &#125;&#125;bool cmp(const Event &amp;a, const Event &amp;b)&#123; return a.time &lt; b.time || a.time == b.time &amp;&amp; a.type &lt; b.type;&#125;bool cmp2(const Event &amp;a, const Event &amp;b)&#123; return a.w &lt; b.w;&#125;void add(int x, int y)&#123; nxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++; nxt[cnt] = head[y]; data[cnt] = x; head[y] = cnt++;&#125;void dfs(int now, int pa)&#123; depth[now] = depth[pa] + 1; anc[now][0] = pa; for (int i = 1; anc[now][i - 1]; i++) anc[now][i] = anc[anc[now][i - 1]][i - 1]; dfn[now] = ++INDEX; for (int i = head[now]; i != -1; i = nxt[i]) &#123; if (data[i] != pa) dfs(data[i], now); &#125; ed[now] = INDEX;&#125;int find_fa(int now, int depth)&#123; FOR(i, 0, 17) if (depth &gt;&gt; i &amp; 1) now = anc[now][i]; return now;&#125;int main()&#123; freopen("fruit.in", "r", stdin); freopen("fruit.out", "w", stdout); memset(head, -1, sizeof head); in(n); in(p); in(q); FOR(i, 1, n - 1) &#123; int u, v; in(u); in(v); add(u, v); &#125; dfs(1, 0); FOR(i, 1, p) &#123; int u, v, w; in(u); in(v); in(w); int anc = lca(u, v); if (dfn[u] &gt; dfn[v]) u ^= v ^= u ^= v; if (u == anc) &#123; int nodes = find_fa(v, depth[v] - depth[u] - 1); int ss = dfn[nodes], tt = ed[nodes]; if (ss != 1) &#123; ev[++ev_tot].time = 1; ev[ev_tot].l = dfn[v]; ev[ev_tot].r = ed[v]; ev[ev_tot].type = appear; ev[ev_tot].w = w; ev[++ev_tot].time = ss - 1; ev[ev_tot].l = dfn[v]; ev[ev_tot].r = ed[v]; ev[ev_tot].type = disappear; ev[ev_tot].w = w; &#125; if (tt != n) &#123; ev[++ev_tot].time = dfn[v]; ev[ev_tot].l = tt + 1; ev[ev_tot].r = n; ev[ev_tot].type = appear; ev[ev_tot].w = w; ev[++ev_tot].time = ed[v]; ev[ev_tot].l = tt + 1; ev[ev_tot].r = n; ev[ev_tot].type = disappear; ev[ev_tot].w = w; &#125; &#125; else &#123; ev[++ev_tot].time = dfn[u]; ev[ev_tot].l = dfn[v]; ev[ev_tot].r = ed[v]; ev[ev_tot].type = appear; ev[ev_tot].w = w; ev[++ev_tot].time = ed[u]; ev[ev_tot].l = dfn[v]; ev[ev_tot].r = ed[v]; ev[ev_tot].type = disappear; ev[ev_tot].w = w; &#125; &#125; std::sort(ev + 1, ev + ev_tot + 1, cmp2); FOR(i, 1, ev_tot) &#123; if (i != 1 &amp;&amp; ev[i].w == ev[i - 1].w) continue; M[ev[i].w] = ++M_point; to[M_point] = ev[i].w; &#125; FOR(i, 1, ev_tot) &#123; ev[i].w = M[ev[i].w]; &#125; FOR(i, 1, q) &#123; int u, v, w; in(u); in(v); in(w); if (dfn[u] &gt; dfn[v]) u ^= v ^= u ^= v; ev[++ev_tot].time = dfn[u]; ev[ev_tot].l = dfn[v]; ev[ev_tot].w = w; ev[ev_tot].num = i; ev[ev_tot].type = query; &#125; std::sort(ev + 1, ev + ev_tot + 1, cmp); segment_tree::initialize(); FOR(i, 1, ev_tot) work(i); FOR(i, 1, q) printf("%d\n", to[ans[i]]); return 0;&#125; Day1 T3 菜肴制作 思路 按照逆序拓扑排序，然后构造字典序最大的解。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using std::priority_queue;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 100010;int T, n, m, chose, du[MAXN], order[MAXN];int cnt, head[MAXN], data[MAXN &lt;&lt; 1], nxt[MAXN &lt;&lt; 1];priority_queue&lt;int&gt;q;void add(int x, int y)&#123; nxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++; nxt[cnt] = head[y]; data[cnt] = x; head[y] = cnt++;&#125;int main()&#123; freopen("dishes.in", "r", stdin); freopen("dishes.out", "w", stdout); in(T); while (T--) &#123; memset(du, 0, sizeof du); memset(head, -1, sizeof head); cnt = 0; in(n); in(m); chose = n; FOR(i, 1, m) &#123; int x, y; in(x); in(y); add(y, x); du[x]++; &#125; FOR(i, 1, n) &#123; if (!du[i]) q.push(i); &#125; order[0] = 0; while (!q.empty()) &#123; int now = q.top(); q.pop(); chose--; order[++order[0]] = now; for (int i = head[now]; i != -1; i = nxt[i]) &#123; du[data[i]]--; if (!du[data[i]]) &#123; q.push(data[i]); &#125; &#125; &#125; if (chose) puts("Impossible!"); else &#123; DNF(i, n, 1) printf("%d ", order[i]); putchar(10); &#125; &#125; return 0;&#125; Day2 T1 落忆枫音 思路 考虑没有环的情况。 每个点（除了 \(1\) 号点）任选一条入边，则构成一棵脉络树。 所有方案数为 \(\prod_{i=2}^ndegree[i]\) 但是有环，所以答案要减去它。 设 \(S\) 为 \(y\) 到 \(x\) 的路径。 \(remove=\sum_{S}\prod_{i=2}^n[i\notin S]degree[i]\) 这个可以dp…… 令 \(f[i]\) 为 \(i\) 到 \(x\) 的路径求出的remove。 则 \(f[i] = \sum_{j-&gt;i}f[j]/degree[i]\) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using std::queue;typedef long long LL;#define FOR(i, a, b) for (LL i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (LL i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const LL MOD = 1000000007;const LL MAXN = 200010;LL n, m, x, y, ans = 1;LL f[MAXN], du[MAXN], rdu[MAXN];LL head[MAXN], data[MAXN], nxt[MAXN], cnt;LL head1[MAXN], data1[MAXN], nxt1[MAXN], cnt1;queue&lt;LL&gt;q;void add(LL x, LL y)&#123; nxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++;&#125;void add2(LL x, LL y)&#123; nxt1[cnt1] = head1[x]; data1[cnt1] = y; head1[x] = cnt1++;&#125;LL power(LL x, LL y)&#123; LL ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % MOD; x = 1ll * x * x % MOD; y &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; freopen("maple.in", "r", stdin); freopen("maple.out", "w", stdout); memset(head, -1, sizeof head); memset(head1, -1, sizeof head1); in(n); in(m); in(x); in(y); FOR(i, 1, m) &#123; LL u, v; in(u); in(v); add(u, v); add2(v, u); du[v]++; rdu[v]++; &#125; FOR(i, 2, n) if (i != y) ans = 1ll * ans * du[i] % MOD; if (x == y || y == 1) &#123; if (y != 1) ans = 1ll * ans * du[x] % MOD; printf("%lld\n", ans); return 0; &#125; LL tmp = ans; ans = 1ll * ans * (du[y] + 1) % MOD; FOR(i, 1, n) &#123; if (!du[i]) q.push(i); &#125; while (!q.empty()) &#123; LL now = q.front(); q.pop(); if (now == y) &#123; f[now] = tmp; &#125; else &#123; f[now] = 0; for (LL i = head1[now]; i != -1; i = nxt1[i]) &#123; f[now] = (f[now] + f[data1[i]]) % MOD; &#125; f[now] = 1ll * f[now] * power(rdu[now], MOD - 2) % MOD; &#125; for (LL i = head[now]; i != -1; i = nxt[i]) &#123; du[data[i]]--; if (!du[data[i]]) &#123; q.push(data[i]); &#125; &#125; &#125; printf("%lld\n", (ans - f[x] + MOD) % MOD); return 0;&#125; Day2 T2 这是一道动态点分治的题目。但因为我还没有搞这个专题所以暂且跳过。 Day2 T3 思路 这个题目还是很容易的。 因为所有的 \(x\) 互不相同， 所以可以把大小关系看作是图论中的边。 那么构成的就是一座森林（把相等的点用并差集缩起来）。 然后就可以树形dp辣！ 因为有等于，所以我们不知道每棵子树中有多少“块”元素。 我们把相等的元素看成一块，那么一棵子树就是若干个块的大小关系。 我们设第 \(i\) 个点的子树中有 \(j\) 个块的方案数为 \(f[i][j]\)。 则两棵子树合并的结果 \(g[i]\) 为 \[g[i]=\sum_{j=1}^n\sum_{k=1}^n[max(j, k)\leq i\leq j+k]f[son1][j]\cdot f[son2][j]\cdot \binom{i}{j}\binom{j}{j+k-i}\] 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 110;const int MOD = 1000000007;struct Edge &#123; int l, r;&#125; edge[MAXN];int edge_lenth;int n, m;char compare[10];int du[MAXN], f[MAXN][MAXN];int head[MAXN], nxt[MAXN], data[MAXN], cnt;int fa[MAXN];int find(int x)&#123; int tmp = x, pre; while (tmp != fa[tmp]) tmp = fa[tmp]; while (x != tmp) &#123; pre = fa[x]; fa[x] = tmp; x = pre; &#125; return tmp;&#125;void merge(int x, int y)&#123; int fx = find(x), fy = find(y); if (fx != fy) fa[fx] = fy;&#125;int g[MAXN], jie[MAXN], ni[MAXN];int C(int x, int y)&#123; if (!y) return 1; if (x &lt; y) return 0; return 1ll * jie[x] * ni[y] % MOD * ni[x - y] % MOD;&#125;void dfs(int now)&#123; for (int i = head[now]; i != -1; i = nxt[i]) dfs(data[i]); memset(g, 0, sizeof g); if (head[now] != -1) FOR(k, 1, n) g[k] = f[data[head[now]]][k]; if (head[now] != -1) for (int i = nxt[head[now]]; i != -1; i = nxt[i]) &#123; memset(f[now], 0, sizeof f[now]); FOR(k, 1, n) FOR(l, 1, n) FOR(j, Max(k, l), Min(n, k + l)) &#123; f[now][j] = ( f[now][j] + 1ll * g[k] % MOD * f[data[i]][l] % MOD * C(j, k) % MOD * C(k, k + l - j) % MOD ) % MOD; &#125; FOR(k, 1, n) g[k] = f[now][k]; &#125; if (head[now] == -1) f[now][1] = 1; else FOR(i, 1, n) f[now][i] = g[i - 1];&#125;int power(int x, int y)&#123; int ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % MOD; x = 1ll * x * x % MOD; y &gt;&gt;= 1; &#125; return ret;&#125;void add(int x, int y)&#123; nxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++;&#125;int main()&#123; freopen("pairwise.in", "r", stdin); freopen("pairwise.out", "w", stdout); memset(head, -1, sizeof head); jie[0] = 1; FOR(i, 1, 100) jie[i] = 1ll * jie[i - 1] * i % MOD; ni[100] = power(jie[100], MOD - 2); DNF(i, 99, 1) ni[i] = 1ll * ni[i + 1] * (i + 1) % MOD; ni[0] = 1; in(n); in(m); FOR(i, 1, n) fa[i] = i; FOR(i, 1, m) &#123; int x, y; in(x); scanf("%s", compare); in(y); if (compare[0] == '&lt;') &#123; edge[++edge_lenth].l = x; edge[edge_lenth].r = y; &#125; else merge(x, y); &#125; int ans = 0; FOR(i, 1, edge_lenth) &#123; int fx = find(edge[i].l); int fy = find(edge[i].r); if (fx == fy) &#123; puts("0"); return 0; &#125; add(fx, fy); du[fy]++; &#125; int rot = 0; FOR(i, 1, n) &#123; if (!du[find(i)]) rot = find(i); &#125; if (!rot) &#123; puts("0"); return 0; &#125; dfs(rot); FOR(i, 1, n) ans = (ans + f[rot][i]) % MOD; printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170406总结]]></title>
      <url>%2F2017%2F04%2F06%2Ftest20170406%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170406总结 做题顺序：T1-&gt;T2-&gt;T3-&gt;T1 T1 这个题目我想到了标算的一半，将 \(i^j\) 转化成了 \(i\) 只有不到 \(30\) 而且是 \(i\cdot j\) 的问题。 但是正解后面的部分我完全没有想法。 由于做这题的时候时间还很充裕，所以我想了N多错误做法，一一对拍卡掉，最后只能弃疗了。 关键是picks没有给我的这个部分分！！！ 我可以做 \(n,m\leq 10^5\) 的情况，但是picks的70分只有 \(n\leq 10^5\)…… 期望得分：40分。 实际得分：40分。 T2 发现这个题目构造的图就是一些不相交的环。 于是每个点只有一条出边、一条入边。 用 \(f[i][j]\) 表示前 \(i\) 个点往外连边之后，每个点是否有入边的状态是 \(j\)，状压dp即可。 期望得分：60 实际得分：60分。 T3 \(30\) 分的暴力直接用高精度。 然后另外 \(30\) 分的暴力直接模拟就好了。 期望得分：60 实际得分：60分。 总结 期望得分：160 实际得分：160…… 今天对了拍，真是特别稳。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HNOI2014解题报告]]></title>
      <url>%2F2017%2F04%2F05%2FHNOI2014%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
      <content type="text"><![CDATA[HNOI2014解题报告 Author: Pengyihao Day1 T1 画框 思路 这个题目我其实是没有思路的。 网上说要用一种高深的最小乘积生成树的算法，我就学了一下。 我们把每一种搭配方案中，\(A\) 的和记做 \(x\)，\(B\) 的和记做 \(y\)。 那么一种搭配方案就可以看做一个坐标 \((x, y)\)。 因为 \(disharmony = x\cdot y\)，所以我们可以把 \(disharmony\) 看作反比例函数的 \(k\)。 因为反比例函数越靠近原点，\(k\) 越小。 所以我们要 \((x, y)\) 尽可能靠近原点。 找到 \(x\) 最小的方案 \(l\)，和 \(y\) 最小的方案 \(r\)，分别求出它们的坐标。 为什么大家都用KM算法，就我用费用流？好怕怕啊 然后我们就要找到在这两个方案的坐标的连线的下方，且三个方案形成的三角形面积最大的方案。 这个面积用叉积可以计算，最后发现形如 \(aA+bB\)，其中 \(A, B\) 是题目中的那个东西。 于是我们可以再跑一遍费用流求出这个方案 \(mid\)。 递归处理 \((l, mid)\) 和 \((mid, r)\)。 边界就是 \(l == mid || mid == r\)。 这个据说递归次数期望是 \(\sqrt{\ln n}\)，然后复杂度就对了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (LL i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (LL i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const LL MAXN = 80;LL n, A[MAXN][MAXN], B[MAXN][MAXN], tmp[MAXN][MAXN];namespace KM&#123; using std::queue; queue&lt;LL&gt;q; bool in_stack[MAXN &lt;&lt; 1]; const LL ss = 0, tt = 159; LL cnt, ret1, ret2, dis[MAXN &lt;&lt; 1], pre[MAXN &lt;&lt; 1]; LL head[MAXN &lt;&lt; 1], data[MAXN * MAXN &lt;&lt; 2], flow[MAXN * MAXN &lt;&lt; 2]; LL wei1[MAXN * MAXN &lt;&lt; 2], wei2[MAXN * MAXN &lt;&lt; 2], nxt[MAXN * MAXN &lt;&lt; 2], wei[MAXN * MAXN &lt;&lt; 2]; void add(LL x, LL y, LL z, LL l, LL l1, LL l2) &#123; nxt[cnt] = head[x]; data[cnt] = y; flow[cnt] = z; wei[cnt] = l; wei1[cnt] = l1; wei2[cnt] = l2; head[x] = cnt++; nxt[cnt] = head[y]; data[cnt] = x; flow[cnt] = 0; wei[cnt] =-l; wei1[cnt] =-l1; wei2[cnt] =-l2; head[y] = cnt++; &#125; bool bfs() &#123; memset(pre, -1, sizeof pre); memset(dis, 0x3f, sizeof dis); dis[ss] = 0; q.push(ss); in_stack[ss] = true; while (!q.empty()) &#123; LL now = q.front(); q.pop(); in_stack[now] = false; for (LL i = head[now]; i != -1; i = nxt[i]) &#123; if (flow[i] &amp;&amp; dis[data[i]] &gt; dis[now] + wei[i]) &#123; dis[data[i]] = dis[now] + wei[i]; pre[data[i]] = i; if (!in_stack[data[i]]) &#123; in_stack[data[i]] = true; q.push(data[i]); &#125; &#125; &#125; &#125; return pre[tt] != -1; &#125; void dfs() &#123; for (LL i = tt; pre[i] != -1; i = data[pre[i] ^ 1]) ret1 += wei1[pre[i]]; for (LL i = tt; pre[i] != -1; i = data[pre[i] ^ 1]) ret2 += wei2[pre[i]]; for (LL i = tt; pre[i] != -1; i = data[pre[i] ^ 1]) flow[pre[i]]--, flow[pre[i] ^ 1]++; &#125; std::pair&lt;LL, LL&gt;main(LL argv[MAXN][MAXN]) &#123; ret1 = ret2 = 0; cnt = 0; memset(head, -1, sizeof head); FOR(i, 1, n) add(ss, i, 1, 0, 0, 0); FOR(i, 1, n) FOR(j, 1, n) &#123; add(i, j + n, 1, argv[i][j], A[i][j], B[i][j]); &#125; FOR(i, 1, n) add(i + n, tt, 1, 0, 0, 0); while (bfs()) dfs(); return std::make_pair(ret1, ret2); &#125;&#125;bool gongxian(std::pair&lt;LL, LL&gt;l, std::pair&lt;LL, LL&gt;mid, std::pair&lt;LL, LL&gt;r)&#123; return (l.second - r.second) * (l.first - mid.first) == (l.second - mid.second) * (l.first - r.first);&#125;LL get_ans(std::pair&lt;LL, LL&gt;l, std::pair&lt;LL, LL&gt;r)&#123; if (l.first == r.first || l.second == r.second) return Min(l.first * l.second, r.first * r.second); FOR(i, 1, n) FOR(j, 1, n) tmp[i][j] = -((r.second - l.second) * A[i][j] + (l.first - r.first) * B[i][j]); std::pair&lt;LL, LL&gt;mid = KM::main(tmp); if (gongxian(l, mid, r)) return Min(l.first * l.second, r.first * r.second); return Min(get_ans(l, mid), get_ans(mid, r));&#125;int main()&#123; freopen("frame.in", "r", stdin); freopen("frame.out", "w", stdout); LL tcase; in(tcase); while (tcase--) &#123; in(n); FOR(i, 1, n) FOR(j, 1, n) in(A[i][j]); FOR(i, 1, n) FOR(j, 1, n) in(B[i][j]); std::pair&lt;LL, LL&gt;retA = KM::main(A), retB = KM::main(B); printf("%lld\n", get_ans(retA, retB)); &#125; return 0;&#125; Day1 T2 世界树 思路 这也是我没学过的算法——虚树。 首先用单调栈维护右链，把虚树构建出来； 然后对于虚树上的每条边，把它的分界点找出来，然后分段赋给管理端点的那两个点。 注意判断管理端点的两个点相同的情况。 这个题目的构建虚树需要用lca，我用了倍增。 这个题目找到分界点也需要用倍增。 没有使用数据结构，代码却比数据结构题还要长。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include &lt;bits/stdc++.h&gt;typedef long long LL;#define debug(...) fprintf(stderr, __VA_ARGS__)#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 300010;bool is_chs[MAXN];int n, q, num[MAXN], fa[MAXN], dfn[MAXN], sa[MAXN], depth[MAXN], sz[MAXN];int INDEX, cnt, head[MAXN], data[MAXN &lt;&lt; 1], nxt[MAXN &lt;&lt; 1], log_num[1000010];int anc[MAXN][20], xsz[MAXN], val[MAXN];void add(int x, int y)&#123; nxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++; nxt[cnt] = head[y]; data[cnt] = x; head[y] = cnt++;&#125;void dfs(int now, int pa)&#123; sz[now] = 1; depth[now] = depth[pa] + 1; fa[now] = pa; dfn[now] = ++INDEX; for (int i = head[now]; i != -1; i = nxt[i]) &#123; if (data[i] != pa) &#123; dfs(data[i], now); sz[now] += sz[data[i]]; &#125; &#125;&#125;void dfs_anc(int now, int pa)&#123; anc[now][0] = pa; for (int i = 1; anc[now][i - 1] != -1; i++) &#123; anc[now][i] = anc[anc[now][i - 1]][i - 1]; &#125; for (int i = head[now]; i != -1; i = nxt[i]) &#123; if (data[i] != pa) dfs_anc(data[i], now); &#125;&#125;namespace get_lca&#123; int eula[MAXN * 3], st[MAXN], ed[MAXN], IND, to[MAXN]; int minx[MAXN * 3][21]; void dfs2(int now) &#123; eula[++eula[0]] = ++IND; st[now] = eula[0]; to[IND] = now; for (int i = head[now]; i != -1; i = nxt[i]) &#123; if (data[i] != fa[now]) &#123; dfs2(data[i]); eula[++eula[0]] = eula[st[now]]; &#125; &#125; ed[now] = eula[0]; &#125; int lca(int x, int y) &#123; if (!x || !y) return 0; if (st[x] &gt; ed[y]) std::swap(x, y); x = st[x]; y = ed[y]; int delta = log_num[y - x + 1]; return to[Min(minx[x][delta], minx[y - (1 &lt;&lt; delta) + 1][delta])]; &#125; void start() &#123; FOR(i, 1, eula[0]) minx[i][0] = eula[i]; FOR(i, 1, 20) &#123; FOR(j, 1, eula[0]) &#123; if (j + (1 &lt;&lt; i) - 1 &gt; eula[0]) break; minx[j][i] = Min(minx[j][i - 1], minx[j + (1 &lt;&lt; (i - 1))][i - 1]); &#125; &#125; FOR(i, 1, 1000000) log_num[i] = log2(i); &#125;&#125;int stack[MAXN], top, in_tree[MAXN];int head_xu[MAXN], cnt_xu, nxt_xu[MAXN &lt;&lt; 1], data_xu[MAXN &lt;&lt; 1];namespace build_tree&#123; void add_xu(int x, int y) &#123; nxt_xu[cnt_xu] = head_xu[x]; data_xu[cnt_xu] = y; head_xu[x] = cnt_xu++; nxt_xu[cnt_xu] = head_xu[y]; data_xu[cnt_xu] = x; head_xu[y] = cnt_xu++; &#125; bool cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125; void builds_tree() &#123; cnt_xu = 0; stack[top = 1] = 0; in_tree[0] = 0; FOR(i, 1, num[0]) &#123; is_chs[num[i]] = true; in_tree[++in_tree[0]] = num[i]; &#125; in_tree[++in_tree[0]] = 0; std::sort(in_tree + 1, in_tree + in_tree[0] + 1, cmp); int now_in_tree = in_tree[0]; FOR(i, 2, now_in_tree) &#123; int now = in_tree[i]; int anc = get_lca::lca(stack[top], now); if (anc == stack[top]) stack[++top] = now; else &#123; while (true) &#123; int tp = stack[top], tp_l = stack[top - 1]; if (tp_l == anc) &#123; add_xu(tp_l, tp); top--; break; &#125; else if (dfn[tp_l] &gt; dfn[anc]) &#123; add_xu(tp_l, tp); top--; &#125; else &#123; in_tree[++in_tree[0]] = anc; add_xu(anc, tp); stack[top] = anc; break; &#125; &#125; stack[++top] = now; &#125; &#125; while (top != 1) &#123; add_xu(stack[top - 1], stack[top]); top--; &#125; &#125;&#125;namespace find_father&#123; int find(int x, int y) &#123; for (int i = 19; i &gt;= 0; i--) &#123; if (y &amp; (1 &lt;&lt; i)) &#123; x = anc[x][i]; &#125; &#125; return x; &#125;&#125;namespace DP&#123; int f[MAXN][2], g[MAXN][2], ret[MAXN]; void dp1(int now, int pa) &#123; val[now] = 0; xsz[now] = 1; f[now][0] = is_chs[now] ? 0 : 0x3f3f3f3f; f[now][1] = now; for (int i = head_xu[now]; i != -1; i = nxt_xu[i]) &#123; if (data_xu[i] != pa) &#123; dp1(data_xu[i], now); xsz[now] += xsz[data_xu[i]]; int frm = depth[data_xu[i]] - depth[now]; if (f[now][0] &gt; f[data_xu[i]][0] + frm || f[now][0] == f[data_xu[i]][0] + frm &amp;&amp; f[now][1] &gt; f[data_xu[i]][1]) &#123; f[now][1] = f[data_xu[i]][1]; f[now][0] = f[data_xu[i]][0] + frm; &#125; &#125; &#125; &#125; void dp2(int now, int pa) &#123; g[now][0] = f[now][0]; g[now][1] = f[now][1]; if (pa != -1) &#123; int frm = depth[now] - depth[pa]; if (g[now][0] &gt; g[pa][0] + frm || g[now][0] == g[pa][0] + frm &amp;&amp; g[now][1] &gt; g[pa][1]) &#123; g[now][1] = g[pa][1]; g[now][0] = g[pa][0] + frm; &#125; &#125; for (int i = head_xu[now]; i != -1; i = nxt_xu[i]) &#123; if (data_xu[i] != pa) dp2(data_xu[i], now); &#125; &#125; int getr(int x, int y, int z, bool t) &#123; if (y - x + z &lt; 0) return 0; if (t) return (y - x + z) / 2; else &#123; if ((y - x + z) % 2 == 0) return (y - x + z) / 2; else return (y - x + z) / 2 + 1; &#125; &#125; void dp3(int now, int pa) &#123; if (!pa) &#123; ret[g[now][1]] += n - sz[now]; &#125; bool flag = false; for (int i = head_xu[now]; i != -1; i = nxt_xu[i]) if (data_xu[i] != pa) &#123; flag = true; int nnum = data_xu[i], all; if (now) &#123; all = depth[nnum] - depth[now] - 1; if (g[now][1] == g[nnum][1]) &#123; if (all) &#123; int pos = find_father::find(nnum, all); ret[g[now][1]] += sz[pos] - sz[nnum]; val[now] -= sz[pos]; &#125; else val[now] -= sz[nnum]; &#125; else &#123;// ret[g[now][1]] += getr(g[now][0], g[nnum][0], all,// g[now][1] &gt; g[nnum][1]);// ret[g[nnum][1]] += getr(g[nnum][0], g[now][0], all,// g[nnum][1] &gt; g[now][1]); if (!all) &#123; val[now] -= sz[nnum]; &#125; else &#123; int Anc = getr(g[nnum][0], g[now][0], all, g[nnum][1] &gt; g[now][1]); int pos = find_father::find(nnum, Anc); ret[g[nnum][1]] += sz[pos] - sz[nnum]; int pos2 = find_father::find(nnum, all); ret[g[now][1]] += sz[pos2] - sz[pos]; val[now] -= sz[pos2]; &#125; &#125; &#125; dp3(nnum, now); &#125; &#125; void dp4(int now, int pa) &#123; if (now) ret[g[now][1]] += sz[now] + val[now]; for (int i = head_xu[now]; i != -1; i = nxt_xu[i]) &#123; if (data_xu[i] != pa) dp4(data_xu[i], now); &#125; &#125; void work() &#123; build_tree::builds_tree(); FOR(i, 1, num[0]) ret[num[i]] = 0; dp1(0, -1); dp2(0, -1); dp3(0, -1); dp4(0, -1); FOR(i, 1, num[0]) printf("%d ", ret[num[i]]); putchar(10); &#125;&#125;int main()&#123; freopen("worldtree.in", "r", stdin); freopen("worldtree.out", "w", stdout); memset(head, -1, sizeof head); memset(head_xu, -1, sizeof head_xu); in(n); FOR(i, 1, n - 1) &#123; int x, y; in(x); in(y); add(x, y); &#125; memset(anc, -1, sizeof anc); dfs(1, 0); dfs_anc(1, 0); get_lca::dfs2(1); get_lca::start(); FOR(i, 1, n) sa[dfn[i]] = i; in(q); FOR(i, 1, q) &#123; FOR(i, 1, num[0]) is_chs[num[i]] = false; FOR(i, 1, in_tree[0]) head_xu[in_tree[i]] = -1; in(num[0]); FOR(j, 1, num[0]) in(num[j]); DP::work(); &#125; return 0;&#125; Day1 T3 米特运输 思路 根据每个点的权值，计算出根节点的权值。 然后用 \(n-\) 根节点权值的众数即可。 因为数据太大，所以需要取对数。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;const int MAXN = 500010;long double rot[MAXN], val[MAXN];int n, w[MAXN], tot[MAXN];int cnt, head[MAXN], data[MAXN &lt;&lt; 1], nxt[MAXN &lt;&lt; 1];void add(int x, int y)&#123; nxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++; nxt[cnt] = head[y]; data[cnt] = x; head[y] = cnt++;&#125;void dfs1(int now, int pa)&#123; for (int i = head[now]; i != -1; i = nxt[i]) if (data[i] != pa) &#123; tot[now]++; dfs1(data[i], now); &#125;&#125;void dfs2(int now, int pa)&#123; for (int i = head[now]; i != -1; i = nxt[i]) &#123; if (data[i] != pa) &#123; val[data[i]] = log(tot[now]) + val[now]; dfs2(data[i], now); &#125; &#125;&#125;const long double eps = 1e-6;int main()&#123; freopen("meat.in", "r", stdin); freopen("meat.out", "w", stdout); memset(head, -1, sizeof head); in(n); FOR(i, 1, n) in(w[i]); FOR(i, 1, n - 1) &#123;int u, v; in(u); in(v); add(u, v);&#125; dfs1(1, 0); dfs2(1, 0); FOR(i, 1, n) rot[i] = val[i] + log(w[i]); std::sort(rot + 1, rot + n + 1); int ret = 0, line = 0; FOR(i, 1, n) &#123; if (i == 1 || fabs(rot[i] - rot[i - 1]) &gt; eps) &#123; chkmax(ret, line); line = 1; &#125; else line++; &#125; chkmax(ret, line); printf("%d\n", n - ret); return 0;&#125; Day2 T1 抄卡组 思路 首先，如果所有的字符串都有通配符，那么只需要两两比较前缀和后缀即可。 就是按每个字符串不包含通配符的最大前缀长度进行排序，比较一遍； 然后按每个字符串不包含通配符的最大后缀长度进行排序，比较一边。 如果所有的字符串都没有通配符，那么只需要比较hash值就可以了。 如果有些有通配符，有些没有通配符，将没有通配符的进行比较，看是否相同。 然后对于有通配符的，将通配符视作分隔符，即把原串分为一段一段的，分开进行匹配。 注意有通配符的字符串和没有通配符的字符串的首尾要对应。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#include &lt;bits/stdc++.h&gt;typedef long long LL;typedef unsigned long long ULL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;const int MAXN = 2000010;using std::string;using std::cin;using std::cout;string str[MAXN];int t, n, len[MAXN];ULL hs[MAXN];const ULL BASE = 31;int prefix[MAXN], suffix[MAXN], numb[MAXN];void gethash(int num)&#123; hs[num] = 0; FOR(i, 0, len[num] - 1) &#123; hs[num] = hs[num] * BASE + str[num][i]; &#125;&#125;bool isop[MAXN];int nopera[MAXN];ULL rhs[MAXN], po[MAXN];ULL power(ULL x, ULL y)&#123; if (!y) return 1; return po[y];&#125;void work()&#123; string *a = str; FOR(i, 1, nopera[0]) isop[nopera[i]] = false; nopera[0] = 0; FOR(i, 1, n) &#123; bool flag = true; FOR(j, 0, len[i] - 1) &#123; if (str[i][j] == '*') &#123; flag = false; break; &#125; &#125; if (flag) &#123; isop[i] = true; nopera[++nopera[0]] = i; &#125; &#125; FOR(i, 2, nopera[0]) &#123; if (hs[nopera[i]] != hs[nopera[i - 1]]) &#123; puts("N"); return; &#125; &#125; int need_compare = nopera[1]; ULL TBASE = 1; FOR(i, 1, len[need_compare]) &#123; rhs[i] = rhs[i - 1] + str[need_compare][i - 1] * TBASE; TBASE = TBASE * BASE; &#125; FOR(i, 1, n) if (!isop[i]) &#123; int lastpos = 0; for (int j = 0, k; j &lt;= len[i] - 1; j = k + 1) &#123; k = j; while (k &lt; len[i] &amp;&amp; str[i][k] == '*') k++; j = k; while (k &lt; len[i] &amp;&amp; str[i][k] != '*') k++; k--; if (str[i][k] == '*') break; ULL nowhs = 0, TBASE = 1; FOR(l, j, k) &#123; nowhs = nowhs + str[i][l] * TBASE; TBASE = TBASE * BASE; &#125; while (true) &#123; if (lastpos + (k - j + 1) &gt; len[need_compare]) &#123; puts("N"); return; &#125; if (k == len[i] - 1) &#123; lastpos = len[need_compare] - (k - j + 1); &#125; ULL tmpnow = nowhs; if (rhs[lastpos + (k - j + 1)] - rhs[lastpos] == tmpnow * power(31, lastpos)) &#123; lastpos += (k - j + 1); break; &#125; if (j != 0) &#123; lastpos++; &#125; else &#123; puts("N"); return; &#125; &#125; &#125; &#125; puts("Y");&#125;bool cmp_prefix(int x, int y)&#123; return prefix[x] &lt; prefix[y];&#125;bool cmp_suffix(int x, int y)&#123; return suffix[x] &lt; suffix[y];&#125;int main()&#123; freopen("hs.in", "r", stdin); freopen("hs.out", "w", stdout); po[0] = 1; FOR(i, 1, 2000000) po[i] = po[i - 1] * BASE; std::ios::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; FOR(i, 1, n) cin &gt;&gt; str[i], len[i] = str[i].size(); bool isy = true, isn = true; FOR(i, 1, n) &#123; gethash(i); bool iss = false; FOR(j, 0, len[i] - 1) &#123; if (str[i][j] == '*') isn = false, iss = true; &#125; if (!iss) isy = false; &#125; if (isn) &#123; bool flag = false; FOR(i, 2, n) if (hs[i] != hs[i - 1]) &#123; flag = true; break; &#125; if (!flag) puts("Y"); else puts("N"); continue; &#125; else if (isy) &#123; FOR(i, 1, n) &#123; FOR(j, 0, len[i] - 1) &#123; if (str[i][j] == '*') &#123; prefix[i] = j; break; &#125; &#125; DNF(j, len[i] - 1, 0) &#123; if (str[i][j] == '*') &#123; suffix[i] = len[i] - 1 - j; break; &#125; &#125; &#125; bool flag = true; FOR(i, 1, n) numb[i] = i; std::sort(numb + 1, numb + n + 1, cmp_prefix); FOR(i, 2, n) &#123; int last = numb[i - 1], now = numb[i]; FOR(j, 1, prefix[last]) &#123; if (str[last][j - 1] != str[now][j - 1]) &#123; flag = false; puts("N"); break; &#125; &#125; if (!flag) break; &#125; if (!flag) continue; std::sort(numb + 1, numb + n + 1, cmp_suffix); FOR(i, 2, n) &#123; int last = numb[i - 1], now = numb[i]; FOR(j, 1, suffix[last]) &#123; if (str[last][len[last] - j] != str[now][len[now] - j]) &#123; flag = false; puts("N"); break; &#125; &#125; if (!flag) break; &#125; if (flag) puts("Y"); continue; &#125; else &#123; work(); &#125; &#125; return 0;&#125; Day2 T2 道路堵塞 这是一道玄学题，需要依赖splay的复杂度的不确定性进行解题。 所以我跳过了它。 Day2 T3 江南乐 思路 首先用SG函数就可以做到 \(O(n^2)\) （枚举分开的情况，然后用朴素的统计就行了） 然后因为这题是分石子，我们可以发现分出来的石子很多都是一样的。 其实只可能分出两种石子，大小为 \(n mod i\) 的，和大小为 \(i-n mod i\) 的。 根据数量的奇偶性，最终会被消成不超过两个。 因为只关注奇偶性，所以对于 \(\lfloor n/i\rfloor\) 相等的多种分法，只需要计算最小的 \(i\) 和 \(i+1\) 两种即可。 复杂度为 \(O(n\sqrt{n})\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt; typedef long long LL; #define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--) template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125; template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125; const int MAXN = 100010; int t, f, sg[MAXN], can[MAXN]; int main()&#123; freopen("game.in", "r", stdin); freopen("game.out", "w", stdout); in(t); in(f); FOR(i, 0, f - 1) sg[i] = 0; FOR(i, f, 100000) &#123; for (int j = 2, k; j &lt;= i; j = k + 1) &#123; k = i / (i / j); int s1 = j, s2 = j + 1; int a = ((i % s1) &amp; 1) ? (i / s1 + 1) : 0; int b = ((s1 - (i % s1)) &amp; 1) ? (i / s1) : 0; can[sg[a] ^ sg[b]] = i; a = ((i % s2) &amp; 1) ? (i / s2 + 1) : 0; b = ((s2 - (i % s2)) &amp; 1) ? (i / s2) : 0; can[sg[a] ^ sg[b]] = i; &#125; FOR(j, 0, 100000) if (can[j] != i) &#123; sg[i] = j; break; &#125; &#125; FOR(i, 1, t) &#123; int n, ret = 0; in(n); FOR(j, 1, n) &#123; int x; in(x); ret ^= sg[x]; &#125; if (ret) printf("1"); else printf("0"); if (i != t) printf(" "); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170405总结]]></title>
      <url>%2F2017%2F04%2F05%2Ftest20170405%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170405总结 做题顺序：T1-&gt;T3-&gt;T2 T1 我的做法是枚举每一条线段，对于长度相等、斜率相等的线段只需要枚举一根就可以了，只要枚举端点在左上角或左上角的就行，这个是 \(O(nm)\) 的。 然后对于每根线段，它的起点能放在哪些地方，这个范围很容易求，把答案乘起来就好了。 然后剩下的问题就转化为，在一根数轴上有 \(n\) 个点，在上面取 \(m\) 个点，使得两两距离不小于 \(d\) 的方案数。 这直接用组合数就可以求了。 所以是 \(O(nm)\) 的？ 不知道为什么答案错了～ 期望得分：100分。 实际得分：20分。 T2 并不会做…… 用 \(f[i][j][k]\) 表示从 \(i\) 到 \(j\) 走了 \(k\) 条边的最长路的长度，每次转移的时候判一下有没有正环即可了…… 这个做法显然是对的，而且十分好写，可还是挂掉了…… 期望得分：60 实际得分：45分。 T3 这是最惨的一道题。 我的做法是先缩点，然后枚举右边区间的端点，再用set维护左边区间。 是 \(O(10^6\log 10^6)\) 的。 但是因为题目中没有说明 \(A[i]\) 的范围！！！ 我以为是 \(1000000\) 级别的！！！ 没有用MAP！！！ 然后RE辣！！！ 加了一个MAP就AC了！！！ 期望得分：100 实际得分：30分。 总结 期望得分：260 实际得分：95…… 好尴尬啊 两天没考试，手又生了…… 总是莫名其妙的错误……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HNOI2013解题报告]]></title>
      <url>%2F2017%2F04%2F02%2Fhnoi2013%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
      <content type="text"><![CDATA[HNOI2013解题报告 Author: Pengyihao Day1 T1 比赛 思路 这是一道搜索的题目。 一个重要的优化就是，因为球队的分数排序后是不影响后面的答案的，所以判重的时候可以很方便。 然后还有就是 \(28^{10}\) 是不会爆 long long 的…… 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;const int MAXN = 20, MOD = 1000000007;LL a[MAXN];std::map&lt;LL, LL&gt;mp;LL hash(int now)&#123; LL res = now, tmp[MAXN]; FOR(i, 1, now) tmp[i] = a[i]; std::sort(tmp + 1, tmp + now + 1, std::less&lt;int&gt;()); FOR(i, 1, now) res += res * 28 + tmp[i]; return res;&#125;LL DFS(int now, int n)&#123; if (a[n] &gt; 3 * (n - now)) return -1; LL res = 0; if (now == n) &#123; if (n == 1) return 1; else &#123; LL h = hash(n - 1); if (mp[h]) return mp[h]; return mp[h] = DFS(1, n - 1); &#125; &#125; if (a[n] &gt;= 3) &#123; LL tmp = 0; a[n] -= 3, tmp = DFS(now + 1, n); if (tmp != -1) (res += tmp) %= MOD; a[n] += 3; &#125; if (a[n] &amp;&amp; a[now]) &#123; LL tmp = 0; a[n]--, a[now]--, tmp = DFS(now + 1, n); if (tmp != -1) (res += tmp) %= MOD; a[n]++, a[now]++; &#125; if (a[now] &gt;= 3) &#123; LL tmp = 0; a[now] -= 3, tmp = DFS(now + 1, n); if (tmp != -1) (res += tmp) %= MOD; a[now] += 3; &#125; return res ? res : -1;&#125;int n;int main()&#123; freopen("match.in", "r", stdin); freopen("match.out", "w", stdout); in(n); FOR(i, 1, n) in(a[i]); std::sort(a + 1, a + n + 1, std::less&lt;int&gt;()); printf("%lld\n", DFS(1, n)); return 0;&#125; Day1 T2 消毒 思路 可以发现最优的话一定要是，选择的区域中的一维为 \(1\)，另外两维为最大值。 因为 \(abc\leq 5000\)，所以它们中的最小值是小于 \(20\) 的。 把这一维看作高，然后枚举每一层选不选。 然后剩下的就转化成了二维问题。 这就是个典型的二分图最小点覆盖，网络流跑就可以了。 时间复杂度为 \(O(\)松\()\) 。注意要进行常数优化。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;bits/stdc++.h&gt;typedef long long LL;#define debug(...) fprintf(stderr, __VA_ARGS__)#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;using std::vector;const int MAXN = 5002;bool chose[20];int a[4], ans;bool map[MAXN][MAXN];std::vector&lt;std::vector&lt;int&gt; &gt;g[MAXN];void init()&#123; ans = 0x3f3f3f3f; FOR(i, 1, 3) in(a[i]); FOR(i, 0, a[1] + 1) &#123; g[i].resize(a[2] + 2); FOR(j, 0, a[2] + 1) g[i][j].resize(a[3] + 2); &#125; FOR(i, 1, a[1]) &#123; FOR(j, 1, a[2]) FOR(k, 1, a[3]) in(g[i][j][k]); &#125;&#125;const int ss = 0, tt = 5008, INF = 0x3f3f3f3f;using std::queue;queue&lt;int&gt;q;bool link[MAXN];int dis[5010], cur[5010];int cnt, head[5010], data[20010], flow[20010], nxt[20010];void add(int x, int y, int z)&#123; nxt[cnt] = head[x]; data[cnt] = y; flow[cnt] = z; head[x] = cnt++; nxt[cnt] = head[y]; data[cnt] = x; flow[cnt] = 0; head[y] = cnt++;&#125;int times, maxx = 1, alledge;struct Edge &#123; int x, y; Edge(int a=0, int b=0): x(a), y(b) &#123;&#125;&#125;;std::vector&lt;Edge&gt;edge[20];bool bfs()&#123; dis[ss] = times; q.push(ss); while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = head[now]; i != -1; i = nxt[i]) &#123; if (dis[data[i]] &lt; times &amp;&amp; flow[i]) &#123; dis[data[i]] = dis[now] + 1; q.push(data[i]); chkmax(maxx, dis[now] + 1); &#125; &#125; &#125; return dis[tt] &gt;= times;&#125;int dfs(int now, int fl)&#123; if (now == tt) return fl; int flo; for (int i = head[now]; i != -1; i = nxt[i]) &#123; if (flow[i] &amp;&amp; dis[data[i]] == dis[now] + 1) &#123; if (flo = dfs(data[i], Min(fl, flow[i]))) &#123; flow[i] -= flo; flow[i ^ 1] += flo; return flo; &#125; &#125; &#125; return 0;&#125;void check(int minx)&#123; int tmptot = 0; FOR(i, 1, minx) if (chose[i]) tmptot++; if (tmptot &gt;= ans) return; cnt = 0; int tot = tmptot;// ***********************************************// make_Edge int Addition; if (minx == a[1]) Addition = a[2]; else if (minx == a[2]) Addition = a[1]; else Addition = a[1]; FOR(k, 1, minx) if (!chose[k]) &#123; FOR(i, 0, edge[k].size() - 1) &#123; int fr = edge[k][i].x, to = edge[k][i].y + Addition; if (!map[fr][to - Addition]) &#123; add(fr, to, 1); if (!link[fr]) &#123;link[fr] = true; add(ss, fr, 1);&#125; if (!link[to]) &#123;link[to] = true; add(to, tt, 1);&#125; &#125; &#125; &#125; // *********************************************** int fl = 0; times = maxx + 1; while (bfs()) &#123; //memcpy(cur, head, sizeof head); int tmp; while (tmp = dfs(ss, INF)) fl += tmp; times = maxx + 1; &#125; chkmin(ans, fl + tot); FOR(k, 1, minx) if (!chose[k]) FOR(i, 0, edge[k].size() - 1) &#123; map[edge[k][i].x][edge[k][i].y] = false; link[edge[k][i].x] = link[edge[k][i].y + Addition] = false; head[edge[k][i].x] = head[edge[k][i].y + Addition] = -1; &#125; head[ss] = head[tt] = -1;&#125;void search(int now, int minx)&#123; chose[now] = false; if (now == minx) check(minx); else search(now + 1, minx); chose[now] = true; if (now == minx) check(minx); else search(now + 1, minx); chose[now] = false;&#125;void work()&#123; memset(head, -1, sizeof head); int minx = 5000; FOR(i, 1, 3) chkmin(minx, a[i]); alledge = 0; FOR(i, 1, minx) &#123; edge[i].clear(); &#125; if (minx == a[1]) &#123; FOR(k, 1, a[1]) &#123; FOR(i, 1, a[2]) FOR(j, 1, a[3]) if (g[k][i][j]) edge[k].push_back(Edge(i, j)); &#125; &#125; else if (minx == a[2]) &#123; FOR(i, 1, a[1]) FOR(k, 1, a[2]) &#123; FOR(j, 1, a[3]) if (g[i][k][j]) edge[k].push_back(Edge(i, j)); &#125; &#125; else &#123; FOR(i, 1, a[1]) FOR(j, 1, a[2]) FOR(k, 1, a[3]) &#123; if (g[i][j][k]) edge[k].push_back(Edge(i, j)); &#125; &#125; search(1, minx); printf("%d\n", ans); debug("%d\n", ans);&#125;int main()&#123; freopen("clear.in", "r", stdin); freopen("clear.out", "w", stdout); int tcase; in(tcase); while (tcase--) &#123; init(); work(); &#125; return 0;&#125; Day1 T3 旅行 这是一道很难的题目。我看了题解也暂时无法解决此题，所以决定跳过它。 Day2 T1 数列 思路 考虑差分数列。 差分数列的可能数量为 \(m^{k-1}\)。 于是答案就为 \(\sum{n-\sum_{i=1}^{k-1}{a_i}}\) 其中 \(a_i\) 表示差分数列的第 \(i\) 项，最前面的 \(\sum\) 表示枚举的差分数列。 \(n\) 可以提出来，而 \(a_i\) 的贡献是独立的。 所以最后答案为 \[m^{k-1}\times n - m(m+1)/2\times (k-1)\times m^{k-2}\] 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;LL ans = 0;LL n, k, m, p;LL power(LL x, LL y, LL p)&#123; x %= p; LL ret = 1; while (y) &#123; if (y &amp; 1) ret = 1ll * ret * x % p; x = 1ll * x * x % p; y &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; freopen("seq.in", "r", stdin); freopen("seq.out", "w", stdout); in(n); in(k); in(m); in(p); n %= p; ans = 1ll * power(m, k - 1, p) * n % p; ans = ((ans - 1ll * (1ll * m * (m + 1) / 2) % p * (k - 1) % p * power(m, k - 2, p) % p) % p + p) % p; printf("%lld\n", ans); return 0;&#125; Day2 T2 游走 思路 我们可以贪心来做——求出每条边走过的期望次数，然后从大到小分配从 \(1\) 到 \(m\) 的编号。 边的期望次数的求法是一个裸的高斯消元，这里就不再赘述。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt; const int MAXN = 510; bool f[MAXN][MAXN];int n, m, du[MAXN], all;long double matrix[MAXN][MAXN], times[MAXN], timess[MAXN * MAXN]; template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125; void gauss() &#123; for (int j = 1; j &lt;= n; j++) &#123; long double maxu = -1; int maxv = 0; for (int i = j; i &lt;= n + 1; i++) if (maxu &lt; fabs(matrix[i][j])) &#123; maxu = fabs(matrix[i][j]); maxv = i; &#125; for (int i = 1; i &lt;= n + 1; i++) &#123; long double t = matrix[j][i]; matrix[j][i] = matrix[maxv][i]; matrix[maxv][i] = t; &#125; long double eps = matrix[j][j]; if (fabs(eps) &lt; 1e-10) continue; for (int i = 1; i &lt;= n + 1; i++) matrix[j][i] /= eps; for (int i = 1; i &lt;= n + 1; i++) if (i != j) &#123; long double epss = matrix[i][j]; if (fabs(epss) &lt; 1e-10) continue; for (int k = 1; k &lt;= n + 1; k++) matrix[i][k] -= matrix[j][k] * epss; &#125; &#125; for (int i = 1; i &lt;= n; i++) times[i] = matrix[i][n + 1] / matrix[i][i]; for (int i = 1; i &lt;= n; i++) for (int j = i + 1; j &lt;= n; j++) if (f[i][j]) &#123; if (j == n) timess[++all] = times[i] / du[i]; else timess[++all] = times[i] / du[i] + times[j] / du[j]; &#125; std::sort(timess + 1, timess + all + 1); long double ans = 0; for (int i = 1; i &lt;= all; i++) &#123; ans += timess[i] * (all - i + 1); &#125; printf("%.3Lf\n", ans);&#125; int main() &#123; freopen("walk.in", "r", stdin); freopen("walk.out", "w", stdout); in(n); in(m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; in(u); in(v); f[u][v] = f[v][u] = true; if (u != n) du[u]++; if (v != n) du[v]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; n; j++) if (f[i][j]) matrix[i][j] = (long double)(1) / du[j]; matrix[i][i] = -1; if (i == 1) matrix[i][n + 1] = -1; &#125; matrix[n + 1][n] = 1; matrix[n + 1][n + 1] = 1; gauss(); return 0;&#125; Day2 T3 切糕 思路 对于每一个位置，从所有层向上一层连边，容量为点权。 对于每一个位置，从第 \(i\) 层向相邻位置的 \(i-d\) 层连边，容量为 \(+\infty\)。 对于每一个位置，从源点向第一层连边，容量为 \(+\infty\)。 对于每一个位置，从最高层向汇点连边，容量为 \(+\infty\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;#define PLA(i, j, k) ((i) * 2500 + (j) * 50 + (k))typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;int p, qs, r, d;int height[50][50][50];int cnt, dis[200010], head[200010], data[200010 &lt;&lt; 1], flow[200010 &lt;&lt; 1], cur[200010], nxt[200010 &lt;&lt; 1];using std::queue; queue&lt;int&gt;q;const int ss = 0, tt = 200009, INF = 0x3f3f3f3f;bool bfs()&#123; memset(dis, -1, sizeof dis); dis[ss] = 0; q.push(ss); while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = head[now]; i != -1; i = nxt[i]) &#123; if (dis[data[i]] == -1 &amp;&amp; flow[i]) &#123; dis[data[i]] = dis[now] + 1; q.push(data[i]); &#125; &#125; &#125; return dis[tt] != -1;&#125;int dfs(int now, int fl)&#123; if (now == tt) return fl; int flo; for (int &amp;i = cur[now]; i != -1; i = nxt[i]) &#123; if (flow[i] &amp;&amp; dis[data[i]] == dis[now] + 1) &#123; if (flo = dfs(data[i], Min(fl, flow[i]))) &#123; flow[i] -= flo; flow[i ^ 1] += flo; return flo; &#125; &#125; &#125; return 0;&#125;void add(int x, int y, int z)&#123; nxt[cnt] = head[x]; data[cnt] = y; flow[cnt] = z; head[x] = cnt++; nxt[cnt] = head[y]; data[cnt] = x; flow[cnt] = 0; head[y] = cnt++;&#125;int main()&#123; freopen("cake.in", "r", stdin); freopen("cake.out", "w", stdout); memset(head, -1, sizeof head); in(p); in(qs); in(r); in(d); FOR(i, 1, r) &#123; FOR(j, 1, p) FOR(k, 1, qs) in(height[i][j][k]); &#125; FOR(i, 1, p) FOR(j, 1, qs) &#123; add(ss, PLA(i, j, 1), INF); FOR(k, 1, r) &#123; add(PLA(i, j, k), PLA(i, j, k + 1), height[k][i][j]); &#125; add(PLA(i, j, r + 1), tt, INF); &#125; FOR(i, 1, p) FOR(j, 1, qs) &#123; FOR(k, d + 1, r + 1) &#123; if (i != p) add(PLA(i, j, k), PLA(i + 1, j, k - d), INF); if (i != 1) add(PLA(i, j, k), PLA(i - 1, j, k - d), INF); if (j != qs) add(PLA(i, j, k), PLA(i, j + 1, k - d), INF); if (j != 1) add(PLA(i, j, k), PLA(i, j - 1, k - d), INF); &#125; &#125; int fl = 0; while (bfs()) &#123; memcpy(cur, head, sizeof head); int tmp; while (tmp = dfs(ss, INF)) fl += tmp; &#125; printf("%d\n", fl); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HNOI2012解题报告]]></title>
      <url>%2F2017%2F04%2F02%2FHNOI2012%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
      <content type="text"><![CDATA[HNOI2012解题报告 Author: Pengyihao Day1 T1 双十字 思路 因为矩阵总的大小不超过 \(1000000\)，所以我们可以预处理往左最多能延续多少，往右、往上、往下…… 然后我们考虑枚举双十字中间线所在的列。 枚举下面这根横线所在的行。 然后对于这根横线形成的双十字的数量有影响的行，一定在其之上并且长度短于它。 于是对于每段连续的 \(1\)，我们维护一个 \(splay\)。 \(splay\) 的关键字键值为左右延伸的长度，然后记录每个点往上扩展的长度以及自身的长度能够给予的贡献。 这个贡献可以求一下子树的和。 那么每次计算下面这根横线的贡献的时候，直接找到它在 \(splay\) 中的位置，把它左边、右边的区间提取出来，计算贡献即可。 注意必须在第 \(i\) 行的时候插入第 \(i-2\) 行，因为两根横线不相邻。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (LL i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (LL i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;using std::vector;const LL MAXN = 10010, MOD = 1000000009;vector&lt;LL&gt;line[MAXN];vector&lt;LL&gt;lr[MAXN], tp[MAXN], co[MAXN];LL r, c, n;struct Node &#123; Node *ch[2], *fa; LL data1, data2, sum1, sum2, sum3, sz; void clear(); void update(); void rotate(); void insert(LL, LL); LL get_rnk(LL); void splay(Node*); Node *find_key(LL);&#125; *treap;void Node::rotate()&#123; Node *pa = fa; fa = pa -&gt; fa; pa -&gt; fa = this; if (fa != NULL) &#123; bool t = (fa -&gt; ch[0] == pa ? 0 : 1); fa -&gt; ch[t] = this; &#125; bool t = (pa -&gt; ch[0] == this ? 0 : 1); Node *chd = ch[t ^ 1]; ch[t ^ 1] = pa; pa -&gt; ch[t] = chd; if (chd != NULL) chd -&gt; fa = pa; pa -&gt; update(); update();&#125;void Node::splay(Node *top)&#123; while (fa != top) &#123; if (fa -&gt; fa != top) &#123; bool t = (fa -&gt; fa -&gt; ch[0] == fa ? 0 : 1); if (fa -&gt; ch[t] == this) fa -&gt; rotate(), rotate(); else rotate(), rotate(); &#125; else rotate(); &#125; if (top == NULL) treap = this;&#125;LL Node::get_rnk(LL now)&#123; Node *x = this; LL ret = 0; while (true) &#123; if (x -&gt; data1 == now) &#123; return (x -&gt; ch[0] == NULL ? 1 : x -&gt; ch[0] -&gt; sz + 1) + ret; &#125; if (x -&gt; data1 &gt; now) &#123; if (x -&gt; ch[0] == NULL) return ret; x = x -&gt; ch[0]; &#125; else &#123; if (x -&gt; ch[1] == NULL) return x -&gt; sz + ret; ret += (x -&gt; ch[0] == NULL ? 1 : x -&gt; ch[0] -&gt; sz + 1); x = x -&gt; ch[1]; &#125; &#125;&#125;Node* Node::find_key(LL rnk)&#123; Node *x = this; while (true) &#123; if ((x -&gt; ch[0] == NULL ? 1 : x -&gt; ch[0] -&gt; sz + 1) == rnk) return x; else if ((x -&gt; ch[0] == NULL ? 1 : x -&gt; ch[0] -&gt; sz + 1) &lt; rnk) &#123; rnk -= (x -&gt; ch[0] == NULL ? 1 : x -&gt; ch[0] -&gt; sz + 1); x = x -&gt; ch[1]; &#125; else x = x -&gt; ch[0]; &#125;&#125;void Node::insert(LL now, LL now2)&#123; if (treap == NULL) &#123; Node *hr = new Node; hr -&gt; ch[0] = hr -&gt; ch[1] = hr -&gt; fa = NULL; hr -&gt; data1 = now; hr -&gt; data2 = now2; treap = hr; treap -&gt; update(); return; &#125; LL rnk = treap -&gt; get_rnk(now); if (rnk == 0) &#123; Node *hr = new Node; hr -&gt; ch[0] = hr -&gt; fa = NULL; hr -&gt; ch[1] = treap; hr -&gt; data1 = now; hr -&gt; data2 = now2; treap -&gt; fa = hr; hr -&gt; update(); treap = hr; &#125; else if (rnk == treap -&gt; sz) &#123; Node *hr = new Node; hr -&gt; ch[1] = hr -&gt; fa = NULL; hr -&gt; ch[0] = treap; hr -&gt; data1 = now; hr -&gt; data2 = now2; treap -&gt; fa = hr; hr -&gt; update(); treap = hr; &#125; else &#123; Node *hr = new Node; treap -&gt; find_key(rnk) -&gt; splay(NULL); treap -&gt; find_key(rnk + 1) -&gt; splay(treap); hr -&gt; data1 = now; hr -&gt; data2 = now2; hr -&gt; ch[0] = NULL; hr -&gt; ch[1] = treap -&gt; ch[1]; hr -&gt; fa = treap; treap -&gt; ch[1] = hr; hr -&gt; ch[1] -&gt; fa = hr; hr -&gt; update(); treap -&gt; update(); &#125;&#125;void Node::clear()&#123; if (ch[0] != NULL) ch[0] -&gt; clear(); if (ch[1] != NULL) ch[1] -&gt; clear(); delete this;&#125;void Node::update()&#123; sz = 1; sum1 = data1 * data2 % MOD; sum2 = (data1 * (data1 + 1) / 2) * data2 % MOD; sum3 = data2; if (ch[0] != NULL) &#123; sz += ch[0] -&gt; sz; sum1 = (sum1 + ch[0] -&gt; sum1) % MOD; sum2 = (sum2 + ch[0] -&gt; sum2) % MOD; sum3 = (sum3 + ch[0] -&gt; sum3) % MOD; &#125; if (ch[1] != NULL) &#123; sz += ch[1] -&gt; sz; sum1 = (sum1 + ch[1] -&gt; sum1) % MOD; sum2 = (sum2 + ch[1] -&gt; sum2) % MOD; sum3 = (sum3 + ch[1] -&gt; sum3) % MOD; &#125;&#125;int main()&#123; freopen("cross.in", "r", stdin); freopen("cross.out", "w", stdout); in(r); in(c); in(n); FOR(i, 0, r + 1) &#123; lr[i].resize(c + 2); tp[i].resize(c + 2); co[i].resize(c + 2); line[i].resize(c + 2); &#125; FOR(i, 1, r) FOR(j, 1, c) line[i][j] = 1; FOR(i, 1, n) &#123; LL x, y; in(x); in(y); line[x][y] = 0; &#125; FOR(i, 1, r) &#123; FOR(j, 1, c) &#123; if (line[i][j] == 0) continue; if (j == 1 || line[i][j - 1] == 0) lr[i][j] = 0; else lr[i][j] = lr[i][j - 1] + 1; &#125; DNF(j, c, 1) &#123; if (line[i][j] == 0) continue; if (j == c || line[i][j + 1] == 0) lr[i][j] = 0; else chkmin(lr[i][j], lr[i][j + 1] + 1); &#125; FOR(j, 1, c) if (line[i][j]) &#123; if (i == 1 || !line[i - 1][j]) tp[i][j] = 0; else tp[i][j] = tp[i - 1][j] + 1; &#125; &#125; DNF(i, r, 1) &#123; FOR(j, 1, c) if (line[i][j]) &#123; if (i == r || !line[i + 1][j]) co[i][j] = 0; else co[i][j] = co[i + 1][j] + 1; &#125; &#125; treap = NULL; bool is_cleared = true; LL ans = 0; FOR(j, 1, c) &#123; if (!is_cleared) &#123; treap -&gt; clear(); treap = NULL; is_cleared = true; &#125; FOR(i, 1, r) &#123; if (i &gt; 2) &#123; if (lr[i - 2][j] != 0 &amp;&amp; line[i - 1][j]) &#123; treap -&gt; insert(lr[i - 2][j], tp[i - 2][j]); is_cleared = false; &#125; &#125; if (!line[i][j]) &#123; if (!is_cleared) &#123; treap -&gt; clear(); treap = NULL; is_cleared = true; &#125; continue; &#125; LL now = lr[i][j]; if (now &amp;&amp; treap != NULL) &#123; LL rnk = treap -&gt; get_rnk(now); if (rnk != 0) &#123; Node *hr; if (rnk != treap -&gt; sz) &#123; treap -&gt; find_key(rnk + 1) -&gt; splay(NULL); treap -&gt; find_key(rnk) -&gt; splay(treap); hr = treap -&gt; ch[0]; &#125; else &#123; treap -&gt; find_key(rnk) -&gt; splay(NULL); hr = treap; &#125; LL fst = hr -&gt; sum1 * now % MOD * co[i][j] % MOD; LL sec = hr -&gt; sum2 * co[i][j] % MOD; ans = (ans + fst - sec) % MOD; &#125; if (rnk != treap -&gt; sz) &#123; Node *hr; if (rnk != 0) &#123; treap -&gt; find_key(rnk) -&gt; splay(NULL); treap -&gt; find_key(rnk + 1) -&gt; splay(treap); hr = treap -&gt; ch[1]; &#125; else &#123; treap -&gt; find_key(rnk + 1) -&gt; splay(NULL); hr = treap; &#125; LL valu = (now * now - now * (now + 1) / 2) * co[i][j] % MOD; ans = (ans + hr -&gt; sum3 * valu % MOD) % MOD; &#125; &#125; &#125; &#125; printf("%lld\n", ans); return 0;&#125; Day1 T2 与非 思路 首先可以发现一个性质——NAND操作可以构成所有的位运算，这个手玩一下就出来了。 然后对于二进制的某两位，我们发现如果对于每一个操作数，他们的这两位都相同，那么不论怎么运算最后肯定还是相同的。 除了这种限制之外，就没有其它限制了。 意思是说，如果在必定相同的两位之间连一条边，那么会形成一个个联通块。联通块与联通块之间两两对于答案的贡献是独立的。 联通块可以用并查集维护。 于是就可以答案进行数位DP辣！！ 对于答案的第 \(i\) 位，它的取值会影响一个联通块的取值。 我们从高到低地做，如果边界的该位上为 \(1\)，那么我们取 \(0\) 的话答案就要加上 \(2^p\)，其中 \(p\) 是尚未确定的联通块个数。 其余的类似。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;const LL MAXN = 1010;LL n, k, l, r, tot, A[MAXN], fa[MAXN];LL find(LL x)&#123; LL tmp = x, pre; while (tmp != fa[tmp]) tmp = fa[tmp]; while (x != tmp) pre = fa[x], fa[x] = tmp, x = pre; return tmp;&#125;void merge(LL x, LL y)&#123; LL fx = find(x), fy = find(y); if (fx != fy) fa[fx] = fy;&#125;LL query(LL x)&#123; if (x &lt; 0) return 0; LL ret = 0, tmp = tot; static bool chose[100]; static bool how_chose[100]; memset(chose, false, sizeof chose); if (x &gt; (1ll &lt;&lt; (k)) - 1) return (1ll &lt;&lt; tmp); DNF(i, k, 1) &#123; if (!(x &amp; (1ll &lt;&lt; (i - 1)))) &#123; LL fx = find(i); if (chose[fx]) &#123; if (how_chose[fx] == 1) return ret; &#125; else &#123; chose[fx] = true; how_chose[fx] = 0; tmp--; continue; &#125; &#125; else &#123; LL fx = find(i); if (chose[fx]) &#123; if (how_chose[fx] == 1) continue; else &#123; ret += (1ll &lt;&lt; tmp); return ret; &#125; &#125; else &#123; chose[fx] = true; how_chose[fx] = 1; tmp--; ret += (1ll &lt;&lt; tmp); continue; &#125; &#125; &#125; return ret + 1;&#125;int main()&#123; freopen("nand.in", "r", stdin); freopen("nand.out", "w", stdout); in(n); in(k); in(l); in(r); FOR(i, 1, n) in(A[i]); FOR(i, 1, k) fa[i] = i; FOR(i, 1, k) &#123; LL tmp = (1ll &lt;&lt; (k)) - 1; FOR(j, 1, n) &#123; if (A[j] &amp; (1ll &lt;&lt; (i - 1))) &#123; tmp &amp;= A[j]; &#125; else tmp &amp;= (A[j] ^ ((1ll &lt;&lt; k) - 1)); &#125; if (!(tmp &amp; (1ll &lt;&lt; (i - 1)))) &#123; puts("WA"); &#125; FOR(j, 1, k) if (j != i) &#123; if (bool(tmp &amp; (1ll &lt;&lt; (j - 1))) == bool(tmp &amp; (1ll &lt;&lt; (i - 1)))) merge(i, j); &#125; &#125; FOR(i, 1, k) if (fa[i] == i) tot++; printf("%lld\n", query(r) - query(l - 1)); return 0;&#125; Day1 T3 排队 思路 首先放男同学，有 \(n!\)。 然后放老师，可以放到一起或分开放，方案分别为 \(n!\times P_{n+1}^2\times P_{n+3}^m\)，和 \(n!\times2(n+1)\)。 最后放女同学。如果老师放在一起了，那么就要放一个女同学在老师中间；否则把老师看作男同学。 总方案为 \[n!\times(P_{n+1}^n\times P_{n+3}^m + 2(n+1)\times P_{n+2}^{m-1}\times m)\] 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define Max(x,y) ((x)&gt;(y)?(x):(y))#define LL long long#define MOD 100000000using namespace std;struct bign&#123; int len; LL s[10000]; bign()&#123; len=1; memset(s,0,sizeof s); s[1]=1; &#125; bign operator = (const LL &amp;num)&#123; len=1; s[1]=num; return *this; &#125; bign operator + (const bign&amp;num)&#123; bign c;c.s[1]=0;c.len=Max(num.len,len); for(int i=1;i&lt;=c.len;i++)&#123; c.s[i+1]=(c.s[i]+s[i]+num.s[i])/MOD; c.s[i]=(c.s[i]+s[i]+num.s[i])%MOD; &#125; if(c.s[c.len+1])c.len++; return c; &#125; bign operator - (const bign&amp;num)&#123; bign c;c.s[1]=0;c.len=len; int x=0; for(int i=1;i&lt;=c.len;i++)&#123; c.s[i]=s[i]-num.s[i]+x; x=0; if(c.s[i]&lt;0)&#123; c.s[i]+=MOD; x=-1; &#125; &#125; while(!c.s[c.len]&amp;&amp;c.len&gt;1)c.len--; return c; &#125; bign operator * (const LL&amp;num)&#123; bign c;c.s[1]=0;c.len=len; for(int i=1;i&lt;=c.len;i++)&#123; c.s[i+1]=(c.s[i]+s[i]*num)/MOD; c.s[i]=(c.s[i]+s[i]*num)%MOD; &#125; if(c.s[c.len+1])c.len++; return c; &#125; bign operator * (const bign&amp;num)&#123; bign c;c.s[1]=0;c.len=len+num.len+1; for(int i=1;i&lt;=len;i++) for(int j=1;j&lt;=num.len;j++)&#123; c.s[i+j]+=(c.s[i+j-1]+s[i]*num.s[j])/MOD; c.s[i+j-1]=(c.s[i+j-1]+s[i]*num.s[j])%MOD; &#125; while(!c.s[c.len]&amp;&amp;c.len&gt;1)c.len--; return c; &#125; void out()&#123; for(int i=len;i&gt;=1;i--)&#123; if(i==len)printf("%lld",s[i]); else printf("%08lld",s[i]); &#125; &#125;&#125;;LL n,m,tmp,tmp2;bign ans1,ans2;int main()&#123; freopen("queue.in", "r", stdin); freopen("queue.out", "w", stdout); scanf("%lld%lld",&amp;n,&amp;m);tmp=n+4;tmp2=n+3; for(LL i=1;i&lt;=n;i++)&#123; ans1=ans1*i; ans2=ans2*i; &#125; ans1=ans1*(n+1)*n; for(LL i=1;i&lt;=m&amp;&amp;tmp&gt;=0;i++)&#123; tmp--; ans1=ans1*tmp; &#125; for(LL i=1;i&lt;=m-1&amp;&amp;tmp2&gt;=0;i++)&#123; tmp2--; ans2=ans2*tmp2; &#125; ans2=ans2*2*m*(n+1); (ans1+ans2).out(); return 0;&#125; Day1 T4 矿场搭建 思路 首先双联通缩点，然后对于每个联通块，只需要每个叶子节点放一个出口就行了（不能放割点）。 方案个数的话乘法原理就好了。 注意只有一个双联通分量的情况要特判！！ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt; const int MAXN = 1010, MAXM = 510; bool is[MAXN];int belong[MAXN];int dfn[MAXN], low[MAXN], INDEX, dot[MAXN], all, sz[MAXN];int n, cnt, head[MAXN], nxt[MAXM &lt;&lt; 1], data[MAXM &lt;&lt; 1], du[MAXN]; template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch != EOF &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == EOF) exit(0); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125; template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125; void add(int x, int y) &#123; nxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++; nxt[cnt] = head[y]; data[cnt] = x; head[y] = cnt++;&#125; void dfs(int now, int rot, int fa) &#123; int size = 0; bool flag = false; dfn[now] = low[now] = ++INDEX; for (int i = head[now]; i != -1; i = nxt[i]) if (!dfn[data[i]]) &#123; size++; dfs(data[i], rot, now); low[now] = Min(low[now], low[data[i]]); if (low[data[i]] &gt;= dfn[now]) flag = true; &#125; else if (data[i] != fa) &#123; low[now] = Min(low[now], dfn[data[i]]); &#125; if (flag &amp;&amp; (now != rot || size &gt;= 2)) &#123; dot[++dot[0]] = now; is[now] = true; &#125;&#125; void dfs2(int now) &#123; dfn[now] = 1; for (int i = head[now]; i != -1; i = nxt[i]) if (!is[data[i]] &amp;&amp; !dfn[data[i]]) &#123; dfs2(data[i]); sz[all]++; belong[data[i]] = all; &#125;&#125; int TTT; int main() &#123; freopen("mining.in", "r", stdin); freopen("mining.out", "w", stdout); while (true) &#123; in(n); int dian = -1; if (!n) return 0; cnt = 0; all = 0; memset(du, 0, sizeof du); memset(is, 0, sizeof is); memset(dot, 0, sizeof dot); memset(dfn, 0, sizeof dfn); memset(low, 0, sizeof low); memset(head, -1, sizeof head); memset(belong, 0, sizeof belong); for (int i = 1; i &lt;= n; i++) &#123; int s, t; in(s); in(t); add(s, t); dian = std::max(dian, std::max(s, t)); &#125; for (int i = 1; i &lt;= dian; i++) if (!dfn[i]) dfs(i, i, -1); memset(dfn, 0, sizeof dfn); for (int i = 1; i &lt;= dian; i++) if (!dfn[i] &amp;&amp; !is[i]) &#123; belong[i] = ++all; sz[all] = 1; dfs2(i); &#125; if (all == 1) &#123; printf("Case %d: %d %d\n", ++TTT, 2, dian * (dian - 1) / 2); continue; &#125; for (int i = 1; i &lt;= dian; i++) if (is[i]) &#123; for (int j = head[i]; j != -1; j = nxt[j]) dfn[belong[data[j]]] = 0; for (int j = head[i]; j != -1; j = nxt[j]) if (!dfn[belong[data[j]]]) &#123; dfn[belong[data[j]]] = true; du[belong[data[j]]]++; &#125; &#125; int tot = 0; long long fang = 1; for (int i = 1; i &lt;= all; i++) &#123; if (du[i] == 1) &#123; tot++; if (sz[i] &gt; 1) fang = fang * (sz[i]); &#125; &#125; printf("Case %d: %d %lld\n", ++TTT, tot, fang); &#125; return 0;&#125; Day2 T1 这是一道计算几何的题目。 因为我还没有进行这个专题，所以我跳过了这道题目。 Day2 T2 这是一道计算几何的题目。 因为我还没有进行这个专题，所以我跳过了这道题目。 Day2 T3 思路 这个题目是一道 \(splay\) 的启发式合并的模板题。 只需要从小的合并到大的中间就可以了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 100010;char command[10];int n, m, rnk[MAXN], fa[MAXN];struct Node &#123; int data, sz, id; Node *ch[2], *fa; void update(); void splay(Node*); void rotate(); Node *find_key(int); void insert(Node*);&#125; *to[MAXN];void Node::rotate()&#123; Node *pa = fa; fa = pa -&gt; fa; if (fa != NULL) &#123; bool t = fa -&gt; ch[0] == pa ? 0 : 1; fa -&gt; ch[t] = this; &#125; pa -&gt; fa = this; bool t = pa -&gt; ch[0] == this ? 0 : 1; Node *chd = ch[t ^ 1]; pa -&gt; ch[t] = chd; if (chd != NULL) chd -&gt; fa = pa; ch[t ^ 1] = pa; pa -&gt; update(); update();&#125;void Node::splay(Node *top)&#123; while (fa != top) &#123; if (fa -&gt; fa != top) &#123; bool t = (fa -&gt; ch[0] == this ? 0 : 1); if (fa -&gt; fa -&gt; ch[t] == fa) &#123; fa -&gt; rotate(); rotate(); &#125; else rotate(), rotate(); &#125; else rotate(); &#125;&#125;Node* Node::find_key(int rnk)&#123; Node *hr = this; while (true) &#123; int nowrnk; nowrnk = (hr -&gt; ch[0] == NULL ? 1 : hr -&gt; ch[0] -&gt; sz + 1); if (nowrnk == rnk) return hr; if (nowrnk &lt; rnk) &#123; rnk -= nowrnk; hr = hr -&gt; ch[1]; &#125; else hr = hr -&gt; ch[0]; &#125;&#125;void Node::update()&#123; sz = 1; if (ch[0] != NULL) sz += ch[0] -&gt; sz; if (ch[1] != NULL) sz += ch[1] -&gt; sz;&#125;void Node::insert(Node *x)&#123; bool t; Node *pos = this, *pa = NULL; while (pos != NULL) &#123; pa = pos; if (x -&gt; data &gt; pos -&gt; data) pos = pos -&gt; ch[1], t = 1; else pos = pos -&gt; ch[0], t = 0; &#125; x -&gt; fa = pa; if (pa != NULL) pa -&gt; ch[t] = x; x -&gt; ch[0] = x -&gt; ch[1] = NULL; while (x != NULL) &#123; x -&gt; update(); x = x -&gt; fa; &#125;&#125;void Ins(Node* now, Node* to)&#123; if (now == NULL) return; Ins(now -&gt; ch[0], to); Ins(now -&gt; ch[1], to); to -&gt; splay(NULL); to -&gt; insert(now); now -&gt; splay(NULL);&#125;int find(int x)&#123; int tmp = x, pre; while (tmp != fa[tmp]) tmp = fa[tmp]; while (x != tmp) pre = fa[x], fa[x] = tmp, x = pre; return tmp;&#125;bool merge(int x, int y)&#123; int fx = find(x), fy = find(y); return fx == fy ? false : fa[fx] = fy, true;&#125;int main()&#123; freopen("neverland.in", "r", stdin); freopen("neverland.out", "w", stdout); in(n); in(m); FOR(i, 1, n) fa[i] = i; FOR(i, 1, n) in(rnk[i]); FOR(i, 1, n) &#123; to[i] = new Node; to[i] -&gt; data = rnk[i]; to[i] -&gt; sz = 1; to[i] -&gt; id = i; to[i] -&gt; fa = to[i] -&gt; ch[0] = to[i] -&gt; ch[1] = NULL; &#125; FOR(i, 1, m) &#123; int x, y; in(x); in(y); if (merge(x, y)) &#123; if (to[x] == NULL) printf("%d\n", x); to[x] -&gt; splay(NULL); to[y] -&gt; splay(NULL); if (to[x] -&gt; sz &lt; to[y] -&gt; sz) &#123; Ins(to[x], to[y]); &#125; else Ins(to[y], to[x]); &#125; &#125; int q; in(q); while (q--) &#123; scanf("%s", command); if (command[0] == 'Q') &#123; int x, k; in(x); in(k); to[x] -&gt; splay(NULL); if (to[x] -&gt; sz &lt; k) printf("-1\n"); else &#123; printf("%d\n", to[x] -&gt; find_key(k) -&gt; id); &#125; &#125; else &#123; int x, y; in(x); in(y); if (merge(x, y)) &#123; to[x] -&gt; splay(NULL); to[y] -&gt; splay(NULL); if (to[x] -&gt; sz &lt; to[y] -&gt; sz) &#123; Ins(to[x], to[y]); &#125; else Ins(to[y], to[x]); &#125; &#125; &#125; return 0;&#125; Day2 T4 集合选数 思路 考虑一张表，将 \(1\) 在左下角。 满足一个性质：对于一个格子，它的右边的格子里的数字是它的 \(3\) 倍，上面的格子里的数字是它的 \(2\) 倍。 于是问题转化为在格子中选不相邻的数的方案数。 表的长宽不会很大，是 \(log\) 级别的。 可能有很多张不相交的表。 状压dp就好了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (register int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (register int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MOD = 1000000001;const int MAXN = 100010;bool vis[MAXN];int n, ans = 1;int map[18][18], end[18], f[2][MAXN &lt;&lt; 1];void solve(int now)&#123; int ret = 0; FOR(i, 1, 100000) &#123; if (i == 1) map[1][i] = now; else map[1][i] = map[1][i - 1] * 2; if (map[1][i] &gt; n) &#123; //map[1][i] = -1; break; &#125; vis[map[1][i]] = true; FOR(j, 2, 100000) &#123; map[j][i] = map[j - 1][i] * 3; if (map[j][i] &gt; n) &#123; //map[j][i] = -1; break; &#125; vis[map[j][i]] = true; &#125; &#125; end[0] = 0; bool t = 0; int all = 1; f[t ^ 1][0] = 1; bool first = true; FOR(i, 1, 100000) &#123; if (map[i][1] &lt;= n) &#123; FOR(j, 1, 100000) if (map[i][j] &gt; n) &#123;end[i] = j - 1; break;&#125; int limits1 = (1 &lt;&lt; end[i]) - 1, limits2 = (1 &lt;&lt; end[i - 1]) - 1; FOR(j, 0, limits1) &#123; f[t][j] = 0; bool flag = true; if (!first &amp;&amp; !f[t ^ 1][j]) continue; FOR(l, 2, end[i]) if ((j &amp; (1 &lt;&lt; (l - 1))) &amp;&amp; (((j) &amp; (1 &lt;&lt; (l - 2))))) &#123; flag = false; break; &#125; if (!flag) continue; FOR(k, 0, limits2) &#123; bool flag = true; if (!f[t ^ 1][k]) continue; FOR(l, 1, end[i]) &#123; if ((j &amp; (1 &lt;&lt; (l - 1))) &amp;&amp; (k &amp; (1 &lt;&lt; (l - 1)))) &#123; flag = false; break; &#125; &#125; if (flag) f[t][j] = (f[t][j] + f[t ^ 1][k]) % MOD; &#125; &#125; &#125; else &#123; all = i - 1; break; &#125; first = false; t ^= 1; &#125; FOR(i, 0, (1 &lt;&lt; (end[all] - 1))) ret = (ret + f[t ^ 1][i]) % MOD; ans = 1ll * ans * ret % MOD;&#125;int main()&#123; freopen("set.in", "r", stdin); freopen("set.out", "w", stdout); in(n); FOR(i, 1, n) &#123; if (!vis[i]) solve(i); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170401总结]]></title>
      <url>%2F2017%2F04%2F02%2Ftest20170401%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170401总结 做题顺序：T1-&gt;T3-&gt;T2 T1 线性基的裸题。 直接求出最大值的排名，然后减掉1之后计算第 \(k\) 大就行了。 期望得分：100分。 实际得分：100分。 T2 不会做，没有一点思路，暴力都不会…… 超才竟然有dp的思路，真是太强了，%%%orzorz 期望得分：0 实际得分：0分。 T3 本来也是不会的。 研究了一下操作发现操作可逆。双向广搜？ 想到ZJOI上有一个神犇曾经批判过我们盲目双向广搜，然后拿到题好像是把所有状态转移到同一个样子。 于是我就想能不能把 \(1\) 往左移。 手玩了几发发现不管什么情况，都可以变成左边一连串 \(1\)，一个\(0\)，然后一个 \(1\)，后面全是 \(0\)； 或者左边一连串 \(1\)，后面全是 \(0\)。 然后发现对于中间间隔了一个 \(0\) 的情况，\(1\) 可以两个两个地增加。 对于左边全是 \(1\) 的情况，\(1\) 可以三个三个地增加。 …… 于是只需要对于每个状态傻逼地往左移， 然后对于每个状态傻逼地往右扩展。 最后发现只有 \(5\) 种情况（包括全 \(1\)，\(0\)）。 比较类别即可。 upd: 当 \(n\) 很小的时候，因为舞台不够大，有一些移动不合法，所以要交暴力。我在 \(n\leq 5\) 的时候是暴力跑的。 期望得分：100 实际得分：100分。 总结 思路有点局限？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170331总结]]></title>
      <url>%2F2017%2F04%2F02%2Ftest20170331%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170331总结 做题顺序：T3-&gt;T1-&gt;T2 T1 不会做…… 在打完第三题之后回来推了一会儿DP，结果并推不出什么，于是就交了一个暴力。 期望得分：30分。 实际得分：30分。 T2 考场上竟然没有想到！！ 一看到题目，看到这么多限制条件，就想不是恶心dp就是网络流。 结果都做不了。于是就弃疗了。因为有分数，所以暴力也打不出。 考完之后谢超才和邱毓淞都看出了这题的本质——多重背包+二进制分组！！！ 看来还是基础知识不杂实…… 期望得分：0 实际得分：0分。 T3 一看到题目，发现是多次询问路径期望。 因为期望有线性性质，可以单独考虑每条边。 于是可以考虑\(f_i\)表示从\(i\)走到\(fa[i]\)的期望步数， \(g_i\)表示从\(fa[i]\)走到\(i\)的期望步数。 这个推一下公式就发现分母都被约掉了…… 为了防止被卡精度，于是我打了long long加倍增。 期望得分：100 实际得分：100分。 总结 基础知识不够杂实。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杜教筛]]></title>
      <url>%2F2017%2F03%2F31%2F%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
      <content type="text"><![CDATA[若 \[h(n) = \sum_{i=1}^n f(i)\] 则有 \[h(n)=\sum_ {i=1}^{n}f(i)\lfloor \frac{n}{i}\rfloor-\sum_ {i=2}^{n}h(\lfloor \frac{n}{i}\rfloor)\]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170330总结]]></title>
      <url>%2F2017%2F03%2F30%2Ftest20170330%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170330总结 做题顺序：T1-&gt;T2-&gt;T3 T1 一开始想了很久怎么让最后一次交易后变成 \(0\)。 后来发现竟然不要输出买进了多少！！ 所以如果最后一次交易后不为 \(0\)，那么只需要在前面某一次买进操作中暗中减少一点进货就好了。 不知道怎么挂掉了？ 期望得分：100分。 实际得分：90分。 T2 这就是一个经典的splay维护区间的问题。 一下子就打完了。 期望得分：100分。 实际得分：100分。 T3 不会做～ 想了一个贪心，就是尽量从最低位选起，选到的火柴丢到最前面去，形成一串的11111111。 最后如果多出来一根火柴就在最高位凑一个7。 应该是对的，但是有一些特殊情况没有考虑（主要是因为时间不够了）。 期望得分：0+分。 实际得分：0分。 总结 做题要仔细…… 最后一题连小数据都没有造…… 我发现自己已经好久没有写过对拍了，下次考试一定要认真对拍……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170328总结]]></title>
      <url>%2F2017%2F03%2F29%2Ftest20170328%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170328总结 做题顺序：T3-&gt;T2-&gt;T1 T1 看到这种题目就我脑袋痛…… 第一眼看上去，我发现这是我一直做不出的一类题——不知道怎么在线段树中，将两个小区间合并成一个大区间。 按照以前的（错误）思路，我写了一个自认为很优的算法。 可是经过严格证明后，发现这是 \(O(n^2\log n)\) 的。 然后我就弃疗了。 后来做了其它题之后，我回过头来，先从两个区间的情况推起。 然后发现了两个区间的做法好像可以推广到 \(k\) 个区间的情况。 我的做法是 \(O(n\log n)\) 的，但是常数有点大，有 \(105\)。 果然被卡常了。 期望得分：100分。 实际得分：70分。 UPD：正解好像是“类似树分治的做法”？区间上为什么有树？ T2 感觉好像有印象，记得好像要转化成图论的问题。 结果推了半天没推出来什么东西…… 打了一个暴力。 期望得分：40分。 实际得分：40分。 T3 并不会做，看到部分分最多就先打这题了。 用简单的树形dp就可以拿60分。 期望得分：60分。 实际得分：60分。 总结 讲过的题目竟然不记得了！！！ 看来要及时总结和反思学过的内容，保证学过的内容都能熟练掌握！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HNOI2011解题报告]]></title>
      <url>%2F2017%2F03%2F28%2FHNOI2011%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
      <content type="text"><![CDATA[HNOI2011解题报告 Author: Pengyihao Day1 T1 数学作业 题意 给出正整数 \(n\), \(m\)，要求将 \(1-n\) 这 \(n\) 个数连接起来，问连接起来的数对 \(m\) 取模的结果是多少。 \(1\leq n\leq 10^{18}, 1\leq m\leq 10^9\) 思路 如果连接的数的位数一样，那么可以用矩阵乘法进行优化。因为有 \[nowans = lastans * 10^k + now\] 这个恒定的递推式（对于位数一样的数），所以可以分段矩阵乘法。 因为只有 \(lg(n)\) 个位数，所以可以解决这个问题。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (LL i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define REP(i, a, b) for (LL i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;LL n; LL m;LL ten[20];LL tmpans;LL ret[4][4], tmp[4][4];void mul(LL x[4][4], LL y[4][4], LL z[4][4])&#123; LL t[4][4]; memset(t, 0, sizeof t); FOR(i, 1, 3) FOR(j, 1, 3) FOR(k, 1, 3) t[i][j] = (t[i][j] + 1ll * x[i][k] * y[k][j] % m) % m; memcpy(z, t, sizeof t);&#125;bool work(LL x)&#123; bool flagend = false; LL ci = ten[x] - ten[x - 1], fr = ten[x - 1] % m; if (n &lt; ten[x]) &#123; ci = n - ten[x - 1] + 1; flagend = true; &#125; memset(ret, 0, sizeof ret); FOR(i, 1, 3) ret[i][i] = 1; memset(tmp, 0, sizeof tmp); tmp[1][1] = 1; tmp[1][2] = 1; tmp[2][2] = 1; tmp[2][3] = 1; tmp[3][3] = ten[x] % m; while (ci) &#123; if (ci &amp; 1) mul(ret, tmp, ret); mul(tmp, tmp, tmp); ci &gt;&gt;= 1; &#125; tmpans = ( 1ll * ret[1][3] % m + 1ll * fr * ret[2][3] % m + 1ll * tmpans * ret[3][3] % m ) % m; if (flagend) &#123; printf("%lld\n", tmpans); return true; &#125; return false;&#125;int main()&#123; freopen("homework.in", "r", stdin); freopen("homework.out", "w", stdout); in(n); in(m); ten[0] = 1; FOR(i, 1, 18) ten[i] = ten[i - 1] * 10; FOR(i, 1, 18) if (work(i)) break; return 0;&#125; Day1 T2 勾股定理 这个题目有点问题，我在网上看题解的时候，发现这题的做法其实是不靠谱的，意思是说这是一道玄学的题目。 对于题目所给的数据范围，标程不一定都能在合理的时间内跑出答案。 所以我就跳过了这道题目。 Day1 T3 赛车游戏 思路 首先可以用拉格朗日乘数法证明，如果要达到最优成绩，那么每条路上的速度要尽可能相等。 于是就可以二分这个速度，然后计算耗油量。 注意如果某条路上耗油量为负数，那么就不能在这条路上用当前二分的速度来计算，因为可能耗油量为负数。 所以我们可以把这条路上的速度设置为令耗油量为0的速度。 这样就可以正确地计算耗油量和跑的时间了。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 10010;int T, n;double a, b, vmax, f;double s[MAXN], k[MAXN], sv[MAXN];const int LIMITS = 1000;double check(double _v)&#123; double sum = 0; FOR(i, 1, n) &#123; if (_v &lt; sv[i]) &#123; sum = sum + Max(0., a * sv[i] + b * k[i]) * s[i]; &#125; else sum = sum + Max(0., a * _v + b * k[i]) * s[i]; &#125; return sum;&#125;int main()&#123; freopen("race.in", "r", stdin); freopen("race.out", "w", stdout); in(T); while (T--) &#123; scanf("%lf%lf%lf%lf", &amp;a, &amp;b, &amp;vmax, &amp;f); in(n); FOR(i, 1, n) &#123; double x, y; scanf("%lf%lf", &amp;x, &amp;y); x /= 1000.0; y /= 1000.0; s[i] = sqrt(x * x + y * y); k[i] = y / x; if (k[i] &lt; 0) sv[i] = Min(-b * k[i] / a, vmax); else sv[i] = 0; &#125; double l = 0, r = 1000000000; FOR(i, 1, LIMITS) &#123; double mid = (l + r) / 2; if (mid &gt; vmax || check(mid) &gt; f) r = mid; else l = mid; &#125; if (check(l) &gt; f) puts("IMPOSSIBLE"); else &#123; double ret = 0; FOR(i, 1, n) &#123; if (sv[i] &gt; l) ret += s[i] / sv[i]; else ret += s[i] / l; &#125; printf("%.5lf\n", ret); &#125; &#125; return 0;&#125; Day1 T4 括号修复 思路 首先对于一个括号序列，如何计算它最少需要改多少个括号呢？ 我们发现如果把可以匹配的括号一层一层去掉，那么最后一定会变成下面这个样子： ))))))))((((((((( 就是左边一连串的括号，右边一连串的括号。 假设左边有 \(l\) 个括号，右边有 \(r\) 个括号。 那么一共要改 \[\lfloor \frac{l+1}{2}\rfloor + \lfloor\frac{r+1}{2}\rfloor\] 个括号。 根据“维修数列”这一题的经验，我们可以用splay来维护括号序列。 用+1表示’(‘，用-1表示’)’，那么左边的括号数量就是从左开始的最小子段和，右边的括号数量就是从右开始的最大子段和。 操作1：直接打标记。 操作2：直接打标记。 操作3：变换一下从左开始的最小、最大子段和，从右开始的最小、最大子段和。 操作4：直接取值。 怎么合并标记呢？ 当打区间赋值标记的时候，可以直接清空反转标记。 当打反转标记的时候，要将赋值标记乘上-1。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; void swap(Tp &amp;x, Tp &amp;y) &#123;Tp z = x; x = y; y = z;&#125;struct Node &#123; bool isa, ist_dn, isset; Node *ch[2], *fa; int lmax, lmin, rmax, rmin, data, sum, sz, wt_set; void update(); void pushdown(); void rotate(); void splay(Node*);&#125;;const int MAXN = 100010;Node *nul, *rot, *to[MAXN];int n, m;char str[MAXN];void push(Node *hr, Node *top)&#123; if (hr != nul) push(hr -&gt; fa, top); if (hr != nul) hr -&gt; pushdown();&#125;void Node::splay(Node *top)&#123; push(this, nul); if (ch[0] != nul) ch[0] -&gt; pushdown(); if (ch[1] != nul) ch[1] -&gt; pushdown(); while (fa != top) &#123; if (fa -&gt; fa != top) &#123; bool t = (fa -&gt; fa -&gt; ch[0] == fa ? 0 : 1); if (fa -&gt; ch[t] == this) &#123; fa -&gt; rotate(); rotate(); &#125; else rotate(), rotate(); &#125; else rotate(); &#125; if (top == nul) rot = this;&#125;void Node::rotate()&#123; Node *pa = fa; fa = pa -&gt; fa; if (fa != nul) &#123; bool t = (fa -&gt; ch[0] == pa ? 0 : 1); fa -&gt; ch[t] = this; &#125; pa -&gt; fa = this; bool t = (pa -&gt; ch[0] == this ? 0 : 1); pa -&gt; ch[t] = ch[t ^ 1]; if (ch[t ^ 1] != nul) ch[t ^ 1] -&gt; fa = pa; ch[t ^ 1] = pa; pa -&gt; update(); update();&#125;void Node::update()&#123; if (ch[0] != nul) ch[0] -&gt; pushdown(); if (ch[1] != nul) ch[1] -&gt; pushdown(); sum = data; sz = 1; if (ch[0] != nul) sum += ch[0] -&gt; sum, sz += ch[0] -&gt; sz; if (ch[1] != nul) sum += ch[1] -&gt; sum, sz += ch[1] -&gt; sz; lmin = Min(0, Min(ch[0] -&gt; lmin, ch[0] -&gt; sum + data + ch[1] -&gt; lmin)); rmin = Min(0, Min(ch[1] -&gt; rmin, ch[1] -&gt; sum + data + ch[0] -&gt; rmin)); lmax = Max(0, Max(ch[0] -&gt; lmax, ch[0] -&gt; sum + data + ch[1] -&gt; lmax)); rmax = Max(0, Max(ch[1] -&gt; rmax, ch[1] -&gt; sum + data + ch[0] -&gt; rmax));&#125;void Node::pushdown()&#123; if (ist_dn) &#123; ist_dn = false; int tlmin = lmin, trmin = rmin; int tlmax = lmax, trmax = rmax; data = -data; sum = -sum; lmin = -tlmax; lmax = -tlmin; rmax = -trmin; rmin = -trmax; wt_set = -wt_set; if (ch[0] != nul) &#123; ch[0] -&gt; ist_dn ^= 1;// if (ch[0] -&gt; isset)// ch[0] -&gt; wt_set = -ch[0] -&gt; wt_set; &#125; if (ch[1] != nul) &#123; ch[1] -&gt; ist_dn ^= 1;// if (ch[1] -&gt; isset)// ch[1] -&gt; wt_set = -ch[1] -&gt; wt_set; &#125; &#125; if (isset) &#123; isset = false; if (ch[0] != nul) ch[0] -&gt; isset = true, ch[0] -&gt; wt_set = wt_set, ch[0] -&gt; ist_dn = false; if (ch[1] != nul) ch[1] -&gt; isset = true, ch[1] -&gt; wt_set = wt_set, ch[1] -&gt; ist_dn = false; data = wt_set; sum = wt_set * sz; lmin = rmin = wt_set &lt; 0 ? wt_set * sz : 0; lmax = rmax = wt_set &gt; 0 ? wt_set * sz : 0; &#125; if (isa) &#123; isa = false; if (ch[0] != nul) ch[0] -&gt; isa ^= 1; if (ch[1] != nul) ch[1] -&gt; isa ^= 1; swap(lmin, rmin); swap(lmax, rmax); swap(ch[0], ch[1]); &#125;&#125;void start()&#123; nul = new Node; nul -&gt; sz = 0; nul -&gt; data = nul -&gt; sum = 0; nul -&gt; isa = nul -&gt; ist_dn = nul -&gt; isset = false; nul -&gt; ch[0] = nul -&gt; ch[1] = nul -&gt; fa = nul; nul -&gt; lmax = nul -&gt; rmax = 0; nul -&gt; lmin = nul -&gt; rmin = 0;&#125;void insert(int now)&#123; to[now] = new Node; if (now == 1) rot = to[now]; to[now] -&gt; sz = 1; to[now] -&gt; isa = to[now] -&gt; isset = to[now] -&gt; ist_dn = false; to[now] -&gt; ch[0] = to[now] -&gt; ch[1] = to[now] -&gt; fa = nul; if (now != 1) to[now] -&gt; fa = to[now - 1], to[now - 1] -&gt; ch[1] = to[now]; to[now] -&gt; data = (str[now] == '(' ? 1 : -1); to[now] -&gt; sum = to[now] -&gt; data;&#125;Node *find_key(int rnk)&#123; Node *x = rot; while (1) &#123; x -&gt; pushdown(); int rrnk = (x -&gt; ch[0] == nul ? 1 : x -&gt; ch[0] -&gt; sz + 1); if (rrnk == rnk) return x; if (rrnk &gt; rnk) x = x -&gt; ch[0]; else &#123; x = x -&gt; ch[1]; rnk -= rrnk; &#125; &#125;&#125;char command[20];int main()&#123; freopen("brackets.in", "r", stdin); freopen("brackets.out", "w", stdout); in(n); in(m); scanf("%s", str + 1); start(); FOR(i, 1, n) insert(i); DNF(i, n, 1) to[i] -&gt; update(); FOR(i, 1, m) &#123; scanf("%s", command); if (command[0] == 'R') &#123; int x, y; in(x); in(y); scanf("%s", command); Node *hr; if (x == 1 &amp;&amp; y == n) hr = rot; if (x == 1 &amp;&amp; y != n) &#123; find_key(y + 1) -&gt; splay(nul); hr = rot -&gt; ch[0]; &#125; if (x != 1 &amp;&amp; y == n) &#123; find_key(x - 1) -&gt; splay(nul); hr = rot -&gt; ch[1]; &#125; if (x != 1 &amp;&amp; y != n) &#123; find_key(x - 1) -&gt; splay(nul); find_key(y + 1) -&gt; splay(rot); hr = find_key(y + 1) -&gt; ch[0]; &#125; hr -&gt; pushdown(); hr -&gt; ist_dn = false; hr -&gt; isset = true; hr -&gt; wt_set = (command[0] == '(' ? 1 : -1); hr -&gt; pushdown(); while (hr -&gt; fa != nul) &#123; hr = hr -&gt; fa; hr -&gt; update(); &#125; &#125; else if (command[0] == 'Q') &#123; int x, y; in(x); in(y); Node *hr; if (x == 1 &amp;&amp; y == n) hr = rot; if (x == 1 &amp;&amp; y != n) &#123; find_key(y + 1) -&gt; splay(nul); hr = rot -&gt; ch[0]; &#125; if (x != 1 &amp;&amp; y == n) &#123; find_key(x - 1) -&gt; splay(nul); hr = rot -&gt; ch[1]; &#125; if (x != 1 &amp;&amp; y != n) &#123; find_key(x - 1) -&gt; splay(nul); find_key(y + 1) -&gt; splay(rot); hr = find_key(y + 1) -&gt; ch[0]; &#125; hr -&gt; pushdown(); printf("%d\n", (-(hr -&gt; lmin) + 1) / 2 + (hr -&gt; rmax + 1) / 2); &#125; else if (command[0] == 'S') &#123; int x, y; in(x); in(y); Node *hr; if (x == 1 &amp;&amp; y == n) hr = rot; if (x == 1 &amp;&amp; y != n) &#123; find_key(y + 1) -&gt; splay(nul); hr = rot -&gt; ch[0]; &#125; if (x != 1 &amp;&amp; y == n) &#123; find_key(x - 1) -&gt; splay(nul); hr = rot -&gt; ch[1]; &#125; if (x != 1 &amp;&amp; y != n) &#123; find_key(x - 1) -&gt; splay(nul); find_key(y + 1) -&gt; splay(rot); hr = find_key(y + 1) -&gt; ch[0]; &#125; hr -&gt; isa ^= 1; hr -&gt; pushdown(); &#125; else if (command[0] == 'I') &#123; int x, y; in(x); in(y); Node *hr; if (x == 1 &amp;&amp; y == n) hr = rot; if (x == 1 &amp;&amp; y != n) &#123; find_key(y + 1) -&gt; splay(nul); hr = rot -&gt; ch[0]; &#125; if (x != 1 &amp;&amp; y == n) &#123; find_key(x - 1) -&gt; splay(nul); hr = rot -&gt; ch[1]; &#125; if (x != 1 &amp;&amp; y != n) &#123; find_key(x - 1) -&gt; splay(nul); find_key(y + 1) -&gt; splay(rot); hr = find_key(y + 1) -&gt; ch[0]; &#125; hr -&gt; ist_dn ^= 1; hr -&gt; pushdown(); while (hr -&gt; fa != nul) &#123; hr = hr -&gt; fa; hr -&gt; update(); &#125; &#125; &#125; return 0;&#125; Day2 T1 任务调度 这是一道随机出答案的题目，所以我没有做，直接跳过了。 Day2 T2 XOR和路径 思路 这是一个简单的概率DP。 因为是XOR，所以我们可以逐位求出期望。 假设当前在处理第 \(k\) 位，设 \(f[i]\) 表示从 \(i\) 到 \(n\) 异或值为 \(1\) 的概率。 则对于 \(i\) 的一个连出去的边所指向的节点 \(j\)，如果边权为 \(1\)，则对 \(f[i]\) 的贡献为 \[\frac{1-f[j]}{deg[i]}\] 如果边权为 \(0\)，则对 \(f[i]\) 的贡献为 \[\frac{f[j]}{deg[i]}\] 最后别忘了 \(f[n]=0\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 110, MAXM = 10010;const double eps = 1e-8;int n, m, cnt, du[MAXN];int head[MAXN], data[MAXM &lt;&lt; 1], nxt[MAXM &lt;&lt; 1], flow[MAXM &lt;&lt; 1];double matrix[MAXN][MAXN];void add(int x, int y, int z)&#123; nxt[cnt] = head[x]; data[cnt] = y; flow[cnt] = z; head[x] = cnt++; if (x != y) &#123;nxt[cnt] = head[y]; data[cnt] = x; flow[cnt] = z; head[y] = cnt++;&#125;&#125;void gauss_george()&#123; FOR(i, 1, n) &#123; double maxv = -1; int maxq; FOR(j, i, n) &#123; if (fabs(matrix[j][i]) &gt; maxv) &#123; maxv = fabs(matrix[j][i]); maxq = j; &#125; &#125; if (fabs(matrix[maxq][i] - maxv) &gt; eps) &#123; assert(0); &#125; if (fabs(matrix[maxq][i]) &lt; eps) continue; FOR(j, 1, n + 1) &#123; double tmp = matrix[i][j]; matrix[i][j] = matrix[maxq][j]; matrix[maxq][j] = tmp; &#125; double chu = matrix[i][i]; FOR(j, 1, n + 1) matrix[i][j] /= chu; FOR(j, 1, n) &#123; if (j != i) &#123; if (fabs(matrix[j][i]) &lt; eps) continue; double chu = matrix[j][i]; FOR(k, 1, n + 1) matrix[j][k] -= matrix[i][k] * chu; &#125; &#125; &#125;&#125;int main()&#123; freopen("xor.in", "r", stdin); freopen("xor.out", "w", stdout); in(n); in(m); memset(head, -1, sizeof head); FOR(i, 1, m) &#123; int u, v, w; in(u); in(v); in(w); add(u, v, w); du[v]++; if (u != v) du[u]++; &#125; double ans = 0; FOR(i, 1, 31) &#123; memset(matrix, 0, sizeof matrix); FOR(j, 1, n - 1) &#123; matrix[j][j] = du[j]; for (int k = head[j]; k != -1; k = nxt[k]) &#123; if (flow[k] &amp; (1 &lt;&lt; (i - 1))) &#123; matrix[j][data[k]] += 1.0; matrix[j][n + 1] += 1.0; &#125; else matrix[j][data[k]] -= 1.0; &#125; &#125; matrix[n][n] = 1; gauss_george(); ans += (1 &lt;&lt; (i - 1)) * matrix[1][n + 1] / matrix[1][1]; &#125; printf("%.3lf\n", ans); return 0;&#125; Day2 T3 数矩形 思路 这又是一道玄学题。 我们找到每条线段的中点，然后按照中点为第一关键字，线段的长度为第二关键字进行排序。 然后对于每个线段，暴力找前面所有跟它中点重合且长度相等的线段…… 这样就可以过了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') ch = getchar(), f = -1; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 2010;struct Node &#123; LL lenth; int posx, posy, rposx[2], rposy[2];&#125; pos[MAXN * MAXN];int n, cnt, x[MAXN], y[MAXN];LL two(LL x) &#123;return x * x;&#125;bool cmp(const Node &amp;x, const Node &amp;y)&#123; bool t1 = x.posx &lt; y.posx; bool t2 = x.posx == y.posx &amp;&amp; x.posy &lt; y.posy; bool t3 = x.posx == y.posx &amp;&amp; x.posy == y.posy &amp;&amp; x.lenth &lt; y.lenth; return t1 || t2 || t3;&#125;LL abs(LL x) &#123;return x &gt; 0 ? x : -x;&#125;int main()&#123; freopen("rectangle.in", "r", stdin); freopen("rectangle.out", "w", stdout); in(n); FOR(i, 1, n) &#123; in(x[i]); in(y[i]); &#125; FOR(i, 1, n) FOR(j, i + 1, n) &#123; pos[++cnt].posx = x[i] + x[j], pos[cnt].posy = y[i] + y[j]; pos[cnt].lenth = two(x[i] - x[j]) + two(y[i] - y[j]); pos[cnt].rposx[0] = x[i]; pos[cnt].rposx[1] = x[j]; pos[cnt].rposy[0] = y[i]; pos[cnt].rposy[1] = y[j]; &#125; std::sort(pos + 1, pos + cnt + 1, cmp); LL ans = -1; FOR(i, 1, cnt) &#123; for (int j = i - 1; j &gt;= 1 &amp;&amp; pos[j].lenth == pos[i].lenth &amp;&amp; pos[i].posx == pos[j].posx &amp;&amp; pos[i].posy == pos[j].posy; j--) chkmax(ans, abs(2ll * pos[i].rposx[0] * pos[j].rposy[0] - 2ll * pos[i].rposy[0] * pos[j].rposx[0] + 1ll * pos[j].rposx[0] * pos[i].posy - 1ll * pos[j].rposy[0] * pos[i].posx + 1ll * pos[i].posx * pos[i].rposy[0] - 1ll * pos[i].posy * pos[i].rposx[0])); &#125; printf("%lld\n", ans); return 0;&#125; Day2 T4 卡农 思路 我们可以先算出可以记片段之间顺序的方案数，因为两两不同，所以最后除以 \(m!\) 就可以了。 设 \(f[i]\) 表示前 \(i\) 个片段满足题意的方案数。 如果前 \(i-1\) 个片段已经决定了，那么第 \(i\) 个片段也可以由奇偶关系决定了。 那么答案就为 \(P(2^n-1, i-1)\) 减去不合法的方案。 这里的 \(P(2^n-1, i-1)\) 可以递推求。 不合法的方案只有两种可能： 前 \(i-1\) 个片段已经满足偶数要求了，那么第 \(i\) 个片段必须是空集合，不符合规定。 所以要减去 \(f[i-1]\)。 被决定出来的第 \(i\) 个片段重复了。 那么与它重复的那个片段有 \(i-1\) 个位置可以选择。 并且如果除了这两个片段之外，其它的片段均满足偶数条件，那么这两个片段一定相同。 而这个片段本身也有 \(2^n-1-(i-2)\) 种可能。 所以要减去 \(f[i-2]\times (i-1)\times (2^n-1-(i-2))\) 所以就可以直接求了。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MOD = 100000007;const int MAXN = 1000010;int n, m;LL f[MAXN];LL power(LL x, LL y)&#123; LL ret = 1; while (y) &#123; if (y &amp; 1) ret = ret * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; freopen("canon.in", "r", stdin); freopen("canon.out", "w", stdout); in(n); in(m); LL pre = 1, po = (power(2, n) - 1 + MOD) % MOD; pre = pre * po % MOD; po = (po - 1 + MOD) % MOD; f[0] = 1; f[1] = 0; FOR(i, 2, m) &#123; f[i] = pre; f[i] = (f[i] - f[i - 1] + MOD) % MOD; f[i] = (f[i] - f[i - 2] * (i - 1) % MOD * (power(2, n) - 1 - (i - 2)) % MOD + MOD) % MOD; pre = pre * po % MOD; po = (po - 1 + MOD) % MOD; &#125; LL ret = 1; FOR(i, 1, m) ret = ret * i % MOD; printf("%lld\n", f[m] * power(ret, MOD - 2) % MOD); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170326总结]]></title>
      <url>%2F2017%2F03%2F26%2Ftest20170326%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170326总结 做题顺序：T2-&gt;T3-&gt;T1 T1 这个题目很复杂，第一眼看过去就知道我做不出来。 因为概率题做得少，所以直接跳过了。 打了一个树的表，结果没得分（严重怀疑数据有问题）。 期望得分：10分。 实际得分：0分。 T2 垃圾题目，大组合数套BSGS，代码300+行。 结果因为一处没取模+没有手写hash用了map替代，结果被卡掉了，只有50分。 期望得分：100分。 实际得分：50分。 T3 这个题目应该是线段树加速dp。 考场上没有想清，打了很久，最后打挂了。 最后只交了暴力。 线段树打两个标记不就可以$O(n\log ^2n)$了吗？ Xie Chaocai一个神犇 感觉好有道理。 期望得分：30分。 实际得分：30分。 总结 考场上太过于紧张，思路不清晰，浪费了大量的时间。 没有压行技巧，导致代码过长，难以调试和对拍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[codeforces235E]]></title>
      <url>%2F2017%2F03%2F25%2Fcodeforces235E%2F</url>
      <content type="text"><![CDATA[题意 求 \[\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^cd(ijk)\] 其中，\(d(i)\) 表示 \(i\) 的约数个数。 \(a, b, c\leq 2000\) Solution 设 \[f(i)=\sum_{j=1}^a\sum_{k=1}^b[j\times k == i]\] 则 \begin{align} &amp;\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^cd(ijk) \\ =&amp;\sum_{i=1}^{ab}f(i)\times \sum_{j=1}^cd(ij) \\ =&amp;\sum_{i=1}^{ab}f(i)\times \sum_{j=1}^c\sum_{u|i}\sum_{v|j}[(u,v)==1] \\ =&amp;\sum_{u=1}^{ab}\sum_{v=1}^c[(u,v)==1]\sum_{u|i}^{ab}\times f(i)\times \lfloor \frac{c}{v}\rfloor \\ =&amp;\sum_{u=1}^{ab}\sum_{d|u}\mu(d)\times \sum_{d|v}\lfloor \frac{c}{v}\rfloor\times \sum_{u|i}^{ab}\times f(i) \\ \end{align} 然后我们发现全部都可以预处理出来！！！ 因为这些枚举倍数的部分都是独立的，而且单单枚举倍数是可以做到\(O(n\log n)\)的。 所以时间复杂度就为\(O(ab\log ab)\)了，要卡常！ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(const Tp &amp;x, const Tp &amp;y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(const Tp &amp;x, const Tp &amp;y) &#123;return x &lt; y ? x : y;&#125;const int MAXN = 4000010, MOD = (1 &lt;&lt; 30);int a, b, c;int prime[MAXN];bool is_prime[MAXN];int h[MAXN], f[MAXN], q[MAXN], g[MAXN], ans, miu[MAXN];void get_prime()&#123; miu[1] = 1; FOR(i, 2, a * b) &#123; if (!is_prime[i]) &#123; prime[++prime[0]] = i; miu[i] = -1; &#125; for (int j = 1; prime[j] * i &lt;= i_END_; j++) &#123; is_prime[prime[j] * i] = true; if (i % prime[j] == 0) &#123; miu[prime[j] * i] = 0; break; &#125; miu[prime[j] * i] = -miu[i]; &#125; &#125;&#125;int main()&#123; in(a); in(b); in(c); get_prime(); FOR(i, 1, c) for (int j = i; j &lt;= c; j += i) h[i] = (h[i] + c / j) % MOD; FOR(i, 1, a) FOR(j, 1, b) f[i * j]++; FOR(i, 1, a * b) for (int j = i; j &lt;= i_END_; j += i) q[i] = (q[i] + f[j]) % MOD; FOR(i, 1, a * b) for (int j = i; j &lt;= i_END_; j += i) g[j] = (g[j] + 1ll * miu[i] * h[i] % MOD) % MOD; FOR(i, 1, a * b) g[i] = 1ll * g[i] * q[i] % MOD; FOR(i, 1, a * b) ans = (ans + g[i]) % MOD; printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170325总结]]></title>
      <url>%2F2017%2F03%2F25%2Ftest20170325%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170325总结 做题顺序：T1-&gt;T2-&gt;T3 T1 这个题目很简单，第一眼看过去就知道可以用很多方法做出来。 我选择了最稳的线段树套pbds，一会儿就写完了，过了对拍。 期望得分：100分。 实际得分：100分。 T2 做了很久都没有做出来，考虑各种方法都失败了。 最后打了一个贪心，想骗一骗分。 期望得分：0+ 实际得分：10分。 upd: 现在还只会做第一问，把元素大小减去下标再求LIS就行了！ T3 这个题目也不会做。 本来想打一个spfa骗一骗分，后来发现好像可以分块。 可是分块打得少，直接挂掉了。 期望得分：0+ 实际得分：0分。 upd: 正解竟然就是spfa！！！ 打一个spfa就可以水过去！！！ 总结 还是思路不够灵活，学过的知识点不能熟练运用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZJOI考试总结]]></title>
      <url>%2F2017%2F03%2F24%2FZJOI%E6%B8%B8%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[ZJOI考试总结 浏览了一边题目，发现ZJOI的题目果然都是变态题。 觉得都只会做暴力，第一题的暴力好像有30分，第三题10~30分，第二题？？ 于是做题顺序为T1-&gt;T3-&gt;T2。 T1 只会做暴力和链的情况。 链的情况就是一个简单的DP就好了。 答案不就是 $2^{n-2}$ 吗？ Xie Chaocai一个神犇 感觉很有道理～ 暴力的话考虑一下DFS的性质，如果一个点 \(u\) 出去的返祖边到了 \(v\)，那么 \(u - v\) 之间是不能有其他的返祖边的起点或终点的。 标记一下就好了 。 期望得分：30分。 #### T3 这个题我没有发现题解中的那个最基本的性质…… 于是直接暴力快速幂+FFT，发现竟然连30分都拿不到！会被卡常！！ 于是只有10分走人…… 期望得分：10分。 T2 这个题真是太变态了。 前面的随机出来的结果，竟然与后面随机出来的结果，一起对之后的询问有着影响。 于是只能搜索了，将所有随机结果的情况全部搜出来，然后暴力更新解就行了。 虚的不行，不知道有没有10分。 期望得分：10分。 ### 总结 还是姿势水平不够，对于性质题没有一点办法…… 计数题和概率题还是做少了题目，一碰到难题就挂掉…… 某匿名神犇：你ZJOI崩了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello world]]></title>
      <url>%2F2017%2F03%2F23%2FHello-world%2F</url>
      <content type="text"><![CDATA[这是第一篇博客，测试一下一些功能？ Title 标题 Sub title 子标题 Sub sub title 子子标题 \[f(x)=f(x_0)+\frac{f&#39;(x_0)(x-x_0)}{1!}+\frac{f&#39;&#39;(x_0)(x-x_0)^2}{2!}+ \cdots +\frac{f^{(n-1)}(x_0)(x-x_0)^{n-1}}{(n-1)!}+\frac{f^{(n)}(\xi)(x-x_0)^n}{n!},x\in[a,b]\] 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;int main()&#123; return 0;&#125;]]></content>
    </entry>

    
  
  
</search>

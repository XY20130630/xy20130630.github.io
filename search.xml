<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[杜教筛]]></title>
      <url>%2F2017%2F03%2F31%2F%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
      <content type="text"><![CDATA[若 \[h(n) = \sum_{i=1}^n f(i)\] 则有 \[h(n)=\sum_ {i=1}^{n}f(i)\lfloor \frac{n}{i}\rfloor-\sum_ {i=2}^{n}h(\lfloor \frac{n}{i}\rfloor)\]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170330总结]]></title>
      <url>%2F2017%2F03%2F30%2Ftest20170330%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170330总结 做题顺序：T1-&gt;T2-&gt;T3 T1 一开始想了很久怎么让最后一次交易后变成 \(0\)。 后来发现竟然不要输出买进了多少！！ 所以如果最后一次交易后不为 \(0\)，那么只需要在前面某一次买进操作中暗中减少一点进货就好了。 不知道怎么挂掉了？ 期望得分：100分。 实际得分：90分。 T2 这就是一个经典的splay维护区间的问题。 一下子就打完了。 期望得分：100分。 实际得分：100分。 T3 不会做～ 想了一个贪心，就是尽量从最低位选起，选到的火柴丢到最前面去，形成一串的11111111。 最后如果多出来一根火柴就在最高位凑一个7。 应该是对的，但是有一些特殊情况没有考虑（主要是因为时间不够了）。 期望得分：0+分。 实际得分：0分。 总结 做题要仔细…… 最后一题连小数据都没有造…… 我发现自己已经好久没有写过对拍了，下次考试一定要认真对拍……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170328总结]]></title>
      <url>%2F2017%2F03%2F29%2Ftest20170328%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170328总结 做题顺序：T3-&gt;T2-&gt;T1 T1 看到这种题目就我脑袋痛…… 第一眼看上去，我发现这是我一直做不出的一类题——不知道怎么在线段树中，将两个小区间合并成一个大区间。 按照以前的（错误）思路，我写了一个自认为很优的算法。 可是经过严格证明后，发现这是 \(O(n^2\log n)\) 的。 然后我就弃疗了。 后来做了其它题之后，我回过头来，先从两个区间的情况推起。 然后发现了两个区间的做法好像可以推广到 \(k\) 个区间的情况。 我的做法是 \(O(n\log n)\) 的，但是常数有点大，有 \(105\)。 果然被卡常了。 期望得分：100分。 实际得分：70分。 UPD：正解好像是“类似树分治的做法”？区间上为什么有树？ T2 感觉好像有印象，记得好像要转化成图论的问题。 结果推了半天没推出来什么东西…… 打了一个暴力。 期望得分：40分。 实际得分：40分。 T3 并不会做，看到部分分最多就先打这题了。 用简单的树形dp就可以拿60分。 期望得分：60分。 实际得分：60分。 总结 讲过的题目竟然不记得了！！！ 看来要及时总结和反思学过的内容，保证学过的内容都能熟练掌握！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HNOI2011解题报告]]></title>
      <url>%2F2017%2F03%2F28%2FHNOI2011%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
      <content type="text"><![CDATA[HNOI2011解题报告 Author: Pengyihao Day1 T1 数学作业 题意 给出正整数 \(n\), \(m\)，要求将 \(1-n\) 这 \(n\) 个数连接起来，问连接起来的数对 \(m\) 取模的结果是多少。 \(1\leq n\leq 10^{18}, 1\leq m\leq 10^9\) 思路 如果连接的数的位数一样，那么可以用矩阵乘法进行优化。因为有 \[nowans = lastans * 10^k + now\] 这个恒定的递推式（对于位数一样的数），所以可以分段矩阵乘法。 因为只有 \(lg(n)\) 个位数，所以可以解决这个问题。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (LL i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define REP(i, a, b) for (LL i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;LL n; LL m;LL ten[20];LL tmpans;LL ret[4][4], tmp[4][4];void mul(LL x[4][4], LL y[4][4], LL z[4][4])&#123; LL t[4][4]; memset(t, 0, sizeof t); FOR(i, 1, 3) FOR(j, 1, 3) FOR(k, 1, 3) t[i][j] = (t[i][j] + 1ll * x[i][k] * y[k][j] % m) % m; memcpy(z, t, sizeof t);&#125;bool work(LL x)&#123; bool flagend = false; LL ci = ten[x] - ten[x - 1], fr = ten[x - 1] % m; if (n &lt; ten[x]) &#123; ci = n - ten[x - 1] + 1; flagend = true; &#125; memset(ret, 0, sizeof ret); FOR(i, 1, 3) ret[i][i] = 1; memset(tmp, 0, sizeof tmp); tmp[1][1] = 1; tmp[1][2] = 1; tmp[2][2] = 1; tmp[2][3] = 1; tmp[3][3] = ten[x] % m; while (ci) &#123; if (ci &amp; 1) mul(ret, tmp, ret); mul(tmp, tmp, tmp); ci &gt;&gt;= 1; &#125; tmpans = ( 1ll * ret[1][3] % m + 1ll * fr * ret[2][3] % m + 1ll * tmpans * ret[3][3] % m ) % m; if (flagend) &#123; printf("%lld\n", tmpans); return true; &#125; return false;&#125;int main()&#123; freopen("homework.in", "r", stdin); freopen("homework.out", "w", stdout); in(n); in(m); ten[0] = 1; FOR(i, 1, 18) ten[i] = ten[i - 1] * 10; FOR(i, 1, 18) if (work(i)) break; return 0;&#125; Day1 T2 勾股定理 这个题目有点问题，我在网上看题解的时候，发现这题的做法其实是不靠谱的，意思是说这是一道玄学的题目。 对于题目所给的数据范围，标程不一定都能在合理的时间内跑出答案。 所以我就跳过了这道题目。 Day1 T3 赛车游戏 思路 首先可以用拉格朗日乘数法证明，如果要达到最优成绩，那么每条路上的速度要尽可能相等。 于是就可以二分这个速度，然后计算耗油量。 注意如果某条路上耗油量为负数，那么就不能在这条路上用当前二分的速度来计算，因为可能耗油量为负数。 所以我们可以把这条路上的速度设置为令耗油量为0的速度。 这样就可以正确地计算耗油量和跑的时间了。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 10010;int T, n;double a, b, vmax, f;double s[MAXN], k[MAXN], sv[MAXN];const int LIMITS = 1000;double check(double _v)&#123; double sum = 0; FOR(i, 1, n) &#123; if (_v &lt; sv[i]) &#123; sum = sum + Max(0., a * sv[i] + b * k[i]) * s[i]; &#125; else sum = sum + Max(0., a * _v + b * k[i]) * s[i]; &#125; return sum;&#125;int main()&#123; freopen("race.in", "r", stdin); freopen("race.out", "w", stdout); in(T); while (T--) &#123; scanf("%lf%lf%lf%lf", &amp;a, &amp;b, &amp;vmax, &amp;f); in(n); FOR(i, 1, n) &#123; double x, y; scanf("%lf%lf", &amp;x, &amp;y); x /= 1000.0; y /= 1000.0; s[i] = sqrt(x * x + y * y); k[i] = y / x; if (k[i] &lt; 0) sv[i] = Min(-b * k[i] / a, vmax); else sv[i] = 0; &#125; double l = 0, r = 1000000000; FOR(i, 1, LIMITS) &#123; double mid = (l + r) / 2; if (mid &gt; vmax || check(mid) &gt; f) r = mid; else l = mid; &#125; if (check(l) &gt; f) puts("IMPOSSIBLE"); else &#123; double ret = 0; FOR(i, 1, n) &#123; if (sv[i] &gt; l) ret += s[i] / sv[i]; else ret += s[i] / l; &#125; printf("%.5lf\n", ret); &#125; &#125; return 0;&#125; Day1 T4 括号修复 思路 首先对于一个括号序列，如何计算它最少需要改多少个括号呢？ 我们发现如果把可以匹配的括号一层一层去掉，那么最后一定会变成下面这个样子： ))))))))((((((((( 就是左边一连串的括号，右边一连串的括号。 假设左边有 \(l\) 个括号，右边有 \(r\) 个括号。 那么一共要改 \[\lfloor \frac{l+1}{2}\rfloor + \lfloor\frac{r+1}{2}\rfloor\] 个括号。 根据“维修数列”这一题的经验，我们可以用splay来维护括号序列。 用+1表示’(‘，用-1表示’)’，那么左边的括号数量就是从左开始的最小子段和，右边的括号数量就是从右开始的最大子段和。 操作1：直接打标记。 操作2：直接打标记。 操作3：变换一下从左开始的最小、最大子段和，从右开始的最小、最大子段和。 操作4：直接取值。 怎么合并标记呢？ 当打区间赋值标记的时候，可以直接清空反转标记。 当打反转标记的时候，要将赋值标记乘上-1。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; void swap(Tp &amp;x, Tp &amp;y) &#123;Tp z = x; x = y; y = z;&#125;struct Node &#123; bool isa, ist_dn, isset; Node *ch[2], *fa; int lmax, lmin, rmax, rmin, data, sum, sz, wt_set; void update(); void pushdown(); void rotate(); void splay(Node*);&#125;;const int MAXN = 100010;Node *nul, *rot, *to[MAXN];int n, m;char str[MAXN];void push(Node *hr, Node *top)&#123; if (hr != nul) push(hr -&gt; fa, top); if (hr != nul) hr -&gt; pushdown();&#125;void Node::splay(Node *top)&#123; push(this, nul); if (ch[0] != nul) ch[0] -&gt; pushdown(); if (ch[1] != nul) ch[1] -&gt; pushdown(); while (fa != top) &#123; if (fa -&gt; fa != top) &#123; bool t = (fa -&gt; fa -&gt; ch[0] == fa ? 0 : 1); if (fa -&gt; ch[t] == this) &#123; fa -&gt; rotate(); rotate(); &#125; else rotate(), rotate(); &#125; else rotate(); &#125; if (top == nul) rot = this;&#125;void Node::rotate()&#123; Node *pa = fa; fa = pa -&gt; fa; if (fa != nul) &#123; bool t = (fa -&gt; ch[0] == pa ? 0 : 1); fa -&gt; ch[t] = this; &#125; pa -&gt; fa = this; bool t = (pa -&gt; ch[0] == this ? 0 : 1); pa -&gt; ch[t] = ch[t ^ 1]; if (ch[t ^ 1] != nul) ch[t ^ 1] -&gt; fa = pa; ch[t ^ 1] = pa; pa -&gt; update(); update();&#125;void Node::update()&#123; if (ch[0] != nul) ch[0] -&gt; pushdown(); if (ch[1] != nul) ch[1] -&gt; pushdown(); sum = data; sz = 1; if (ch[0] != nul) sum += ch[0] -&gt; sum, sz += ch[0] -&gt; sz; if (ch[1] != nul) sum += ch[1] -&gt; sum, sz += ch[1] -&gt; sz; lmin = Min(0, Min(ch[0] -&gt; lmin, ch[0] -&gt; sum + data + ch[1] -&gt; lmin)); rmin = Min(0, Min(ch[1] -&gt; rmin, ch[1] -&gt; sum + data + ch[0] -&gt; rmin)); lmax = Max(0, Max(ch[0] -&gt; lmax, ch[0] -&gt; sum + data + ch[1] -&gt; lmax)); rmax = Max(0, Max(ch[1] -&gt; rmax, ch[1] -&gt; sum + data + ch[0] -&gt; rmax));&#125;void Node::pushdown()&#123; if (ist_dn) &#123; ist_dn = false; int tlmin = lmin, trmin = rmin; int tlmax = lmax, trmax = rmax; data = -data; sum = -sum; lmin = -tlmax; lmax = -tlmin; rmax = -trmin; rmin = -trmax; wt_set = -wt_set; if (ch[0] != nul) &#123; ch[0] -&gt; ist_dn ^= 1;// if (ch[0] -&gt; isset)// ch[0] -&gt; wt_set = -ch[0] -&gt; wt_set; &#125; if (ch[1] != nul) &#123; ch[1] -&gt; ist_dn ^= 1;// if (ch[1] -&gt; isset)// ch[1] -&gt; wt_set = -ch[1] -&gt; wt_set; &#125; &#125; if (isset) &#123; isset = false; if (ch[0] != nul) ch[0] -&gt; isset = true, ch[0] -&gt; wt_set = wt_set, ch[0] -&gt; ist_dn = false; if (ch[1] != nul) ch[1] -&gt; isset = true, ch[1] -&gt; wt_set = wt_set, ch[1] -&gt; ist_dn = false; data = wt_set; sum = wt_set * sz; lmin = rmin = wt_set &lt; 0 ? wt_set * sz : 0; lmax = rmax = wt_set &gt; 0 ? wt_set * sz : 0; &#125; if (isa) &#123; isa = false; if (ch[0] != nul) ch[0] -&gt; isa ^= 1; if (ch[1] != nul) ch[1] -&gt; isa ^= 1; swap(lmin, rmin); swap(lmax, rmax); swap(ch[0], ch[1]); &#125;&#125;void start()&#123; nul = new Node; nul -&gt; sz = 0; nul -&gt; data = nul -&gt; sum = 0; nul -&gt; isa = nul -&gt; ist_dn = nul -&gt; isset = false; nul -&gt; ch[0] = nul -&gt; ch[1] = nul -&gt; fa = nul; nul -&gt; lmax = nul -&gt; rmax = 0; nul -&gt; lmin = nul -&gt; rmin = 0;&#125;void insert(int now)&#123; to[now] = new Node; if (now == 1) rot = to[now]; to[now] -&gt; sz = 1; to[now] -&gt; isa = to[now] -&gt; isset = to[now] -&gt; ist_dn = false; to[now] -&gt; ch[0] = to[now] -&gt; ch[1] = to[now] -&gt; fa = nul; if (now != 1) to[now] -&gt; fa = to[now - 1], to[now - 1] -&gt; ch[1] = to[now]; to[now] -&gt; data = (str[now] == '(' ? 1 : -1); to[now] -&gt; sum = to[now] -&gt; data;&#125;Node *find_key(int rnk)&#123; Node *x = rot; while (1) &#123; x -&gt; pushdown(); int rrnk = (x -&gt; ch[0] == nul ? 1 : x -&gt; ch[0] -&gt; sz + 1); if (rrnk == rnk) return x; if (rrnk &gt; rnk) x = x -&gt; ch[0]; else &#123; x = x -&gt; ch[1]; rnk -= rrnk; &#125; &#125;&#125;char command[20];int main()&#123; freopen("brackets.in", "r", stdin); freopen("brackets.out", "w", stdout); in(n); in(m); scanf("%s", str + 1); start(); FOR(i, 1, n) insert(i); DNF(i, n, 1) to[i] -&gt; update(); FOR(i, 1, m) &#123; scanf("%s", command); if (command[0] == 'R') &#123; int x, y; in(x); in(y); scanf("%s", command); Node *hr; if (x == 1 &amp;&amp; y == n) hr = rot; if (x == 1 &amp;&amp; y != n) &#123; find_key(y + 1) -&gt; splay(nul); hr = rot -&gt; ch[0]; &#125; if (x != 1 &amp;&amp; y == n) &#123; find_key(x - 1) -&gt; splay(nul); hr = rot -&gt; ch[1]; &#125; if (x != 1 &amp;&amp; y != n) &#123; find_key(x - 1) -&gt; splay(nul); find_key(y + 1) -&gt; splay(rot); hr = find_key(y + 1) -&gt; ch[0]; &#125; hr -&gt; pushdown(); hr -&gt; ist_dn = false; hr -&gt; isset = true; hr -&gt; wt_set = (command[0] == '(' ? 1 : -1); hr -&gt; pushdown(); while (hr -&gt; fa != nul) &#123; hr = hr -&gt; fa; hr -&gt; update(); &#125; &#125; else if (command[0] == 'Q') &#123; int x, y; in(x); in(y); Node *hr; if (x == 1 &amp;&amp; y == n) hr = rot; if (x == 1 &amp;&amp; y != n) &#123; find_key(y + 1) -&gt; splay(nul); hr = rot -&gt; ch[0]; &#125; if (x != 1 &amp;&amp; y == n) &#123; find_key(x - 1) -&gt; splay(nul); hr = rot -&gt; ch[1]; &#125; if (x != 1 &amp;&amp; y != n) &#123; find_key(x - 1) -&gt; splay(nul); find_key(y + 1) -&gt; splay(rot); hr = find_key(y + 1) -&gt; ch[0]; &#125; hr -&gt; pushdown(); printf("%d\n", (-(hr -&gt; lmin) + 1) / 2 + (hr -&gt; rmax + 1) / 2); &#125; else if (command[0] == 'S') &#123; int x, y; in(x); in(y); Node *hr; if (x == 1 &amp;&amp; y == n) hr = rot; if (x == 1 &amp;&amp; y != n) &#123; find_key(y + 1) -&gt; splay(nul); hr = rot -&gt; ch[0]; &#125; if (x != 1 &amp;&amp; y == n) &#123; find_key(x - 1) -&gt; splay(nul); hr = rot -&gt; ch[1]; &#125; if (x != 1 &amp;&amp; y != n) &#123; find_key(x - 1) -&gt; splay(nul); find_key(y + 1) -&gt; splay(rot); hr = find_key(y + 1) -&gt; ch[0]; &#125; hr -&gt; isa ^= 1; hr -&gt; pushdown(); &#125; else if (command[0] == 'I') &#123; int x, y; in(x); in(y); Node *hr; if (x == 1 &amp;&amp; y == n) hr = rot; if (x == 1 &amp;&amp; y != n) &#123; find_key(y + 1) -&gt; splay(nul); hr = rot -&gt; ch[0]; &#125; if (x != 1 &amp;&amp; y == n) &#123; find_key(x - 1) -&gt; splay(nul); hr = rot -&gt; ch[1]; &#125; if (x != 1 &amp;&amp; y != n) &#123; find_key(x - 1) -&gt; splay(nul); find_key(y + 1) -&gt; splay(rot); hr = find_key(y + 1) -&gt; ch[0]; &#125; hr -&gt; ist_dn ^= 1; hr -&gt; pushdown(); while (hr -&gt; fa != nul) &#123; hr = hr -&gt; fa; hr -&gt; update(); &#125; &#125; &#125; return 0;&#125; Day2 T1 任务调度 这是一道随机出答案的题目，所以我没有做，直接跳过了。 Day2 T2 XOR和路径 思路 这是一个简单的概率DP。 因为是XOR，所以我们可以逐位求出期望。 假设当前在处理第 \(k\) 位，设 \(f[i]\) 表示从 \(i\) 到 \(n\) 异或值为 \(1\) 的概率。 则对于 \(i\) 的一个连出去的边所指向的节点 \(j\)，如果边权为 \(1\)，则对 \(f[i]\) 的贡献为 \[\frac{1-f[j]}{deg[i]}\] 如果边权为 \(0\)，则对 \(f[i]\) 的贡献为 \[\frac{f[j]}{deg[i]}\] 最后别忘了 \(f[n]=0\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 110, MAXM = 10010;const double eps = 1e-8;int n, m, cnt, du[MAXN];int head[MAXN], data[MAXM &lt;&lt; 1], nxt[MAXM &lt;&lt; 1], flow[MAXM &lt;&lt; 1];double matrix[MAXN][MAXN];void add(int x, int y, int z)&#123; nxt[cnt] = head[x]; data[cnt] = y; flow[cnt] = z; head[x] = cnt++; if (x != y) &#123;nxt[cnt] = head[y]; data[cnt] = x; flow[cnt] = z; head[y] = cnt++;&#125;&#125;void gauss_george()&#123; FOR(i, 1, n) &#123; double maxv = -1; int maxq; FOR(j, i, n) &#123; if (fabs(matrix[j][i]) &gt; maxv) &#123; maxv = fabs(matrix[j][i]); maxq = j; &#125; &#125; if (fabs(matrix[maxq][i] - maxv) &gt; eps) &#123; assert(0); &#125; if (fabs(matrix[maxq][i]) &lt; eps) continue; FOR(j, 1, n + 1) &#123; double tmp = matrix[i][j]; matrix[i][j] = matrix[maxq][j]; matrix[maxq][j] = tmp; &#125; double chu = matrix[i][i]; FOR(j, 1, n + 1) matrix[i][j] /= chu; FOR(j, 1, n) &#123; if (j != i) &#123; if (fabs(matrix[j][i]) &lt; eps) continue; double chu = matrix[j][i]; FOR(k, 1, n + 1) matrix[j][k] -= matrix[i][k] * chu; &#125; &#125; &#125;&#125;int main()&#123; freopen("xor.in", "r", stdin); freopen("xor.out", "w", stdout); in(n); in(m); memset(head, -1, sizeof head); FOR(i, 1, m) &#123; int u, v, w; in(u); in(v); in(w); add(u, v, w); du[v]++; if (u != v) du[u]++; &#125; double ans = 0; FOR(i, 1, 31) &#123; memset(matrix, 0, sizeof matrix); FOR(j, 1, n - 1) &#123; matrix[j][j] = du[j]; for (int k = head[j]; k != -1; k = nxt[k]) &#123; if (flow[k] &amp; (1 &lt;&lt; (i - 1))) &#123; matrix[j][data[k]] += 1.0; matrix[j][n + 1] += 1.0; &#125; else matrix[j][data[k]] -= 1.0; &#125; &#125; matrix[n][n] = 1; gauss_george(); ans += (1 &lt;&lt; (i - 1)) * matrix[1][n + 1] / matrix[1][1]; &#125; printf("%.3lf\n", ans); return 0;&#125; Day2 T3 数矩形 思路 这又是一道玄学题。 我们找到每条线段的中点，然后按照中点为第一关键字，线段的长度为第二关键字进行排序。 然后对于每个线段，暴力找前面所有跟它中点重合且长度相等的线段…… 这样就可以过了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') ch = getchar(), f = -1; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MAXN = 2010;struct Node &#123; LL lenth; int posx, posy, rposx[2], rposy[2];&#125; pos[MAXN * MAXN];int n, cnt, x[MAXN], y[MAXN];LL two(LL x) &#123;return x * x;&#125;bool cmp(const Node &amp;x, const Node &amp;y)&#123; bool t1 = x.posx &lt; y.posx; bool t2 = x.posx == y.posx &amp;&amp; x.posy &lt; y.posy; bool t3 = x.posx == y.posx &amp;&amp; x.posy == y.posy &amp;&amp; x.lenth &lt; y.lenth; return t1 || t2 || t3;&#125;LL abs(LL x) &#123;return x &gt; 0 ? x : -x;&#125;int main()&#123; freopen("rectangle.in", "r", stdin); freopen("rectangle.out", "w", stdout); in(n); FOR(i, 1, n) &#123; in(x[i]); in(y[i]); &#125; FOR(i, 1, n) FOR(j, i + 1, n) &#123; pos[++cnt].posx = x[i] + x[j], pos[cnt].posy = y[i] + y[j]; pos[cnt].lenth = two(x[i] - x[j]) + two(y[i] - y[j]); pos[cnt].rposx[0] = x[i]; pos[cnt].rposx[1] = x[j]; pos[cnt].rposy[0] = y[i]; pos[cnt].rposy[1] = y[j]; &#125; std::sort(pos + 1, pos + cnt + 1, cmp); LL ans = -1; FOR(i, 1, cnt) &#123; for (int j = i - 1; j &gt;= 1 &amp;&amp; pos[j].lenth == pos[i].lenth &amp;&amp; pos[i].posx == pos[j].posx &amp;&amp; pos[i].posy == pos[j].posy; j--) chkmax(ans, abs(2ll * pos[i].rposx[0] * pos[j].rposy[0] - 2ll * pos[i].rposy[0] * pos[j].rposx[0] + 1ll * pos[j].rposx[0] * pos[i].posy - 1ll * pos[j].rposy[0] * pos[i].posx + 1ll * pos[i].posx * pos[i].rposy[0] - 1ll * pos[i].posy * pos[i].rposx[0])); &#125; printf("%lld\n", ans); return 0;&#125; Day2 T4 卡农 思路 我们可以先算出可以记片段之间顺序的方案数，因为两两不同，所以最后除以 \(m!\) 就可以了。 设 \(f[i]\) 表示前 \(i\) 个片段满足题意的方案数。 如果前 \(i-1\) 个片段已经决定了，那么第 \(i\) 个片段也可以由奇偶关系决定了。 那么答案就为 \(P(2^n-1, i-1)\) 减去不合法的方案。 这里的 \(P(2^n-1, i-1)\) 可以递推求。 不合法的方案只有两种可能： 前 \(i-1\) 个片段已经满足偶数要求了，那么第 \(i\) 个片段必须是空集合，不符合规定。 所以要减去 \(f[i-1]\)。 被决定出来的第 \(i\) 个片段重复了。 那么与它重复的那个片段有 \(i-1\) 个位置可以选择。 并且如果除了这两个片段之外，其它的片段均满足偶数条件，那么这两个片段一定相同。 而这个片段本身也有 \(2^n-1-(i-2)\) 种可能。 所以要减去 \(f[i-2]\times (i-1)\times (2^n-1-(i-2))\) 所以就可以直接求了。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;const int MOD = 100000007;const int MAXN = 1000010;int n, m;LL f[MAXN];LL power(LL x, LL y)&#123; LL ret = 1; while (y) &#123; if (y &amp; 1) ret = ret * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; freopen("canon.in", "r", stdin); freopen("canon.out", "w", stdout); in(n); in(m); LL pre = 1, po = (power(2, n) - 1 + MOD) % MOD; pre = pre * po % MOD; po = (po - 1 + MOD) % MOD; f[0] = 1; f[1] = 0; FOR(i, 2, m) &#123; f[i] = pre; f[i] = (f[i] - f[i - 1] + MOD) % MOD; f[i] = (f[i] - f[i - 2] * (i - 1) % MOD * (power(2, n) - 1 - (i - 2)) % MOD + MOD) % MOD; pre = pre * po % MOD; po = (po - 1 + MOD) % MOD; &#125; LL ret = 1; FOR(i, 1, m) ret = ret * i % MOD; printf("%lld\n", f[m] * power(ret, MOD - 2) % MOD); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170326总结]]></title>
      <url>%2F2017%2F03%2F26%2Ftest20170326%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170326总结 做题顺序：T2-&gt;T3-&gt;T1 T1 这个题目很复杂，第一眼看过去就知道我做不出来。 因为概率题做得少，所以直接跳过了。 打了一个树的表，结果没得分（严重怀疑数据有问题）。 期望得分：10分。 实际得分：0分。 T2 垃圾题目，大组合数套BSGS，代码300+行。 结果因为一处没取模+没有手写hash用了map替代，结果被卡掉了，只有50分。 期望得分：100分。 实际得分：50分。 T3 这个题目应该是线段树加速dp。 考场上没有想清，打了很久，最后打挂了。 最后只交了暴力。 线段树打两个标记不就可以$O(n\log ^2n)$了吗？ Xie Chaocai一个神犇 感觉好有道理。 期望得分：30分。 实际得分：30分。 总结 考场上太过于紧张，思路不清晰，浪费了大量的时间。 没有压行技巧，导致代码过长，难以调试和对拍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[codeforces235E]]></title>
      <url>%2F2017%2F03%2F25%2Fcodeforces235E%2F</url>
      <content type="text"><![CDATA[题意 求 \[\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^cd(ijk)\] 其中，\(d(i)\) 表示 \(i\) 的约数个数。 \(a, b, c\leq 2000\) Solution 设 \[f(i)=\sum_{j=1}^a\sum_{k=1}^b[j\times k == i]\] 则 \begin{align} &amp;\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^cd(ijk) \\ =&amp;\sum_{i=1}^{ab}f(i)\times \sum_{j=1}^cd(ij) \\ =&amp;\sum_{i=1}^{ab}f(i)\times \sum_{j=1}^c\sum_{u|i}\sum_{v|j}[(u,v)==1] \\ =&amp;\sum_{u=1}^{ab}\sum_{v=1}^c[(u,v)==1]\sum_{u|i}^{ab}\times f(i)\times \lfloor \frac{c}{v}\rfloor \\ =&amp;\sum_{u=1}^{ab}\sum_{d|u}\mu(d)\times \sum_{d|v}\lfloor \frac{c}{v}\rfloor\times \sum_{u|i}^{ab}\times f(i) \\ \end{align} 然后我们发现全部都可以预处理出来！！！ 因为这些枚举倍数的部分都是独立的，而且单单枚举倍数是可以做到\(O(n\log n)\)的。 所以时间复杂度就为\(O(ab\log ab)\)了，要卡常！ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(); x = 0; while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(const Tp &amp;x, const Tp &amp;y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(const Tp &amp;x, const Tp &amp;y) &#123;return x &lt; y ? x : y;&#125;const int MAXN = 4000010, MOD = (1 &lt;&lt; 30);int a, b, c;int prime[MAXN];bool is_prime[MAXN];int h[MAXN], f[MAXN], q[MAXN], g[MAXN], ans, miu[MAXN];void get_prime()&#123; miu[1] = 1; FOR(i, 2, a * b) &#123; if (!is_prime[i]) &#123; prime[++prime[0]] = i; miu[i] = -1; &#125; for (int j = 1; prime[j] * i &lt;= i_END_; j++) &#123; is_prime[prime[j] * i] = true; if (i % prime[j] == 0) &#123; miu[prime[j] * i] = 0; break; &#125; miu[prime[j] * i] = -miu[i]; &#125; &#125;&#125;int main()&#123; in(a); in(b); in(c); get_prime(); FOR(i, 1, c) for (int j = i; j &lt;= c; j += i) h[i] = (h[i] + c / j) % MOD; FOR(i, 1, a) FOR(j, 1, b) f[i * j]++; FOR(i, 1, a * b) for (int j = i; j &lt;= i_END_; j += i) q[i] = (q[i] + f[j]) % MOD; FOR(i, 1, a * b) for (int j = i; j &lt;= i_END_; j += i) g[j] = (g[j] + 1ll * miu[i] * h[i] % MOD) % MOD; FOR(i, 1, a * b) g[i] = 1ll * g[i] * q[i] % MOD; FOR(i, 1, a * b) ans = (ans + g[i]) % MOD; printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test20170325总结]]></title>
      <url>%2F2017%2F03%2F25%2Ftest20170325%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[test20170325总结 做题顺序：T1-&gt;T2-&gt;T3 T1 这个题目很简单，第一眼看过去就知道可以用很多方法做出来。 我选择了最稳的线段树套pbds，一会儿就写完了，过了对拍。 期望得分：100分。 实际得分：100分。 T2 做了很久都没有做出来，考虑各种方法都失败了。 最后打了一个贪心，想骗一骗分。 期望得分：0+ 实际得分：10分。 upd: 现在还只会做第一问，把元素大小减去下标再求LIS就行了！ T3 这个题目也不会做。 本来想打一个spfa骗一骗分，后来发现好像可以分块。 可是分块打得少，直接挂掉了。 期望得分：0+ 实际得分：0分。 upd: 正解竟然就是spfa！！！ 打一个spfa就可以水过去！！！ 总结 还是思路不够灵活，学过的知识点不能熟练运用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZJOI考试总结]]></title>
      <url>%2F2017%2F03%2F24%2FZJOI%E6%B8%B8%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[ZJOI考试总结 浏览了一边题目，发现ZJOI的题目果然都是变态题。 觉得都只会做暴力，第一题的暴力好像有30分，第三题10~30分，第二题？？ 于是做题顺序为T1-&gt;T3-&gt;T2。 T1 只会做暴力和链的情况。 链的情况就是一个简单的DP就好了。 答案不就是 $2^{n-2}$ 吗？ Xie Chaocai一个神犇 感觉很有道理～ 暴力的话考虑一下DFS的性质，如果一个点 \(u\) 出去的返祖边到了 \(v\)，那么 \(u - v\) 之间是不能有其他的返祖边的起点或终点的。 标记一下就好了 。 期望得分：30分。 #### T3 这个题我没有发现题解中的那个最基本的性质…… 于是直接暴力快速幂+FFT，发现竟然连30分都拿不到！会被卡常！！ 于是只有10分走人…… 期望得分：10分。 T2 这个题真是太变态了。 前面的随机出来的结果，竟然与后面随机出来的结果，一起对之后的询问有着影响。 于是只能搜索了，将所有随机结果的情况全部搜出来，然后暴力更新解就行了。 虚的不行，不知道有没有10分。 期望得分：10分。 ### 总结 还是姿势水平不够，对于性质题没有一点办法…… 计数题和概率题还是做少了题目，一碰到难题就挂掉…… 某匿名神犇：你ZJOI崩了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello world]]></title>
      <url>%2F2017%2F03%2F23%2FHello-world%2F</url>
      <content type="text"><![CDATA[这是第一篇博客，测试一下一些功能？ Title 标题 Sub title 子标题 Sub sub title 子子标题 \[f(x)=f(x_0)+\frac{f&#39;(x_0)(x-x_0)}{1!}+\frac{f&#39;&#39;(x_0)(x-x_0)^2}{2!}+ \cdots +\frac{f^{(n-1)}(x_0)(x-x_0)^{n-1}}{(n-1)!}+\frac{f^{(n)}(\xi)(x-x_0)^n}{n!},x\in[a,b]\] 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;typedef long long LL;#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i &lt;= i##_END_; i++)#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i &gt;= i##_END_; i--)template &lt;typename Tp&gt; void in(Tp &amp;x) &#123; char ch = getchar(), f = 1; x = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;template &lt;typename Tp&gt; Tp chkmax(Tp &amp;x, Tp y) &#123;return x &gt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp chkmin(Tp &amp;x, Tp y) &#123;return x &lt; y ? x : x=y;&#125;template &lt;typename Tp&gt; Tp Max(Tp x, Tp y) &#123;return x &gt; y ? x : y;&#125;template &lt;typename Tp&gt; Tp Min(Tp x, Tp y) &#123;return x &lt; y ? x : y;&#125;int main()&#123; return 0;&#125;]]></content>
    </entry>

    
  
  
</search>
